<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="google-site-verification" content="GY3xi-El9ePp4mSskpCuCNS4x4elE7wbFPe2eKCtS8Y"><title>Day9 Algorithm about Binary Tree | Xinli's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Day9 Algorithm about Binary Tree</h1><a id="logo" href="/.">Xinli's Blog</a><p class="description">Coding World</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Day9 Algorithm about Binary Tree</h1><div class="post-meta">Aug 22, 2016<span> | </span><span class="category"><a href="/categories/Algorithm/">Algorithm</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/" href="/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#攻略模板"><span class="toc-number">1.</span> <span class="toc-text">攻略模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自己回忆"><span class="toc-number">2.</span> <span class="toc-text">自己回忆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现算法"><span class="toc-number">3.</span> <span class="toc-text">实现算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习后总结："><span class="toc-number">4.</span> <span class="toc-text">学习后总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#When-to-use-Pre-Order-In-Order-Post-Order"><span class="toc-number">4.1.</span> <span class="toc-text">When to use Pre-Order, In-Order, Post-Order</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#When-to-use-BFS-and-DFS-the-relationship-between-DFS-and-PreOrder"><span class="toc-number">4.2.</span> <span class="toc-text">When to use BFS and DFS, the relationship between DFS and PreOrder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-think-over-Divide-amp-Conquer"><span class="toc-number">4.3.</span> <span class="toc-text">How to think over Divide&Conquer</span></a></li></ol></li></ol></div></div><div class="post-content"><p>本篇是关于二叉树Binary Tree算法的分析和总结。</p>
<h2 id="攻略模板"><a href="#攻略模板" class="headerlink" title="攻略模板"></a>攻略模板</h2><ul>
<li>回忆算法特性</li>
<li>实现算法功能</li>
<li>实战训练使用该算法</li>
<li>总结该算法特点，并总结算法题</li>
</ul>
<h2 id="自己回忆"><a href="#自己回忆" class="headerlink" title="自己回忆"></a>自己回忆</h2><ul>
<li>一般二叉树的查找可以使用DFS 和 BFS</li>
<li>平衡二叉树可以使用二分法，时间复杂度为O(logn)</li>
<li>二叉树的遍历有先序遍历，中序遍历 和 后序遍历</li>
<li>Binary Tree and Binary Search Tree: Each node of BT and BST only allowed two children nodes. What’s more, in BST, left &lt; current &lt; right.</li>
</ul>
<h2 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h2><p>在这里我们总结出经典15道二叉树题目： </p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Definition for a binary tree node.</span></div><div class="line"><span class="class"><span class="keyword">Class</span> <span class="title">TreeNode</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> val;</div><div class="line">	TreeNode left;</div><div class="line">	TreeNode right;</div><div class="line">	TreeNode(<span class="keyword">int</span> x) &#123;</div><div class="line">		val = x;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.求二叉树中的节点个数: getNodeNumRec（递归），getNodeNum（迭代） </p>
<p>递归解法：Time O(n)<br>(1) 如果二叉树为空，节点个数为0<br>(2) 如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1  </p>
<p>迭代解法：Time O(n)<br>使用DFS 或者 BFS 遍历所有节点，统计节点个数       </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> getNodeNumRec(TreeNode root) &#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> getNodeNumRec(root.left)+getNodeNumRec(root.right)+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Traverse tree use BFS</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> getNodeNum(TreeNode root) &#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">	<span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</div><div class="line">	queue.add(root);</div><div class="line">	<span class="keyword">while</span>(!queue.isEmpty()) &#123;</div><div class="line">		<span class="keyword">int</span> <span class="keyword">size</span> = queue.<span class="keyword">size</span>();</div><div class="line">		<span class="keyword">count</span> += <span class="keyword">size</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">size</span>;i++) &#123;</div><div class="line">			TreeNode node = queue.poll();</div><div class="line">			<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</div><div class="line">			<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.求二叉树的深度: getDepthRec（递归），getDepth(迭代)<br>LeetCode - 104.Maximum Depth of Binary Tree<br>递归解法:  Time O(n)<br>(1) 如果二叉树为空，深度为0<br>(2) 如果二叉树不为空，二叉树深度 = max(左子树深度，右子树的深度) + 1</p>
<p>迭代解法： Time O(n)<br>(1)解法一：使用BFS,统计层数 即 执行循环的次数<br>(2)解法二：使用DFS,每次一条路径到底，比较深度，把所有树遍历一遍，找出最大长度   </p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="built_in">int</span> getDepthRec(TreeNode root) &#123;</div><div class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>) retrun <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(getDepthRec(root.left),getDepthRec(root.right))+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Traverse tree use BFS</span></div><div class="line"><span class="keyword">public</span> <span class="built_in">int</span> getNodeNum(TreeNode root) &#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	<span class="built_in">int</span> count = <span class="number">0</span>;</div><div class="line">	queue.<span class="built_in">add</span>(root);</div><div class="line">	<span class="keyword">while</span>(!queue.isEmpty()) &#123;</div><div class="line">		<span class="built_in">int</span> <span class="built_in">size</span> = queue.<span class="built_in">size</span>();</div><div class="line">		count++;</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++) &#123;</div><div class="line">			TreeNode node = queue.poll();</div><div class="line">			<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.<span class="built_in">add</span>(node.left);</div><div class="line">			<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.<span class="built_in">add</span>(node.right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.前序遍历，中序遍历，后序遍历: preorderTraversalRec, preorderTraversal, inorderTraversalRec, postorderTraversalRec (<a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_2" target="_blank" rel="external">https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_2</a>) </p>
<p>LeetCode - 104.Binary Tree Preorder Traversal<br>Pre-Order递归解法:  Time O(n)<br>(1) 如果二叉树为空，返回<br>(2) 如果二叉树不为空，访问根节点,list.add(root.val), 前序遍历左子树，前序遍历右子树      </p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Solution1: add helper() method</span></div><div class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; preorderTraversalRec(TreeNode root) &#123;</div><div class="line">	<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">	helper(<span class="built_in">list</span>,root);</div><div class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="literal">void</span> helper(<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span>, TreeNode node) &#123;</div><div class="line">	<span class="keyword">if</span>(node==<span class="built_in">null</span>) <span class="keyword">return</span>;</div><div class="line">	<span class="built_in">list</span>.add(node.val);</div><div class="line">	helper(<span class="built_in">list</span>,node.left);</div><div class="line">	helper(<span class="built_in">list</span>,node.right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Solution2</span></div><div class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; preorderTraversalRec(TreeNode root) &#123;</div><div class="line">	<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">	<span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">	<span class="built_in">list</span>.add(root.val);</div><div class="line">	<span class="built_in">list</span>.addAll(preorderTraversalRec(root.left));</div><div class="line">	<span class="built_in">list</span>.addAll(preorderTraversalRec(root.right));</div><div class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Pre-Order迭代解法:  Time O(n), Space O(n)<br>使用Stack, 用List存储输出的节点，每次从右向左遍历子节点, 存入Stack中    </p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; preorderTraversal(TreeNode root) &#123;</div><div class="line">	<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">	<span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">	<span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</div><div class="line">	<span class="built_in">stack</span>.push(root);</div><div class="line">	<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;</div><div class="line">		TreeNode node = <span class="built_in">stack</span>.pop();</div><div class="line">		<span class="built_in">list</span>.add(node.val);</div><div class="line">		<span class="keyword">if</span>(node.right!=<span class="built_in">null</span>)<span class="built_in">stack</span>.push(node.right);</div><div class="line">		<span class="keyword">if</span>(node.left!=<span class="built_in">null</span>)<span class="built_in">stack</span>.push(node.left);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LeetCode - 94.Binary Tree Inorder Traversal<br>In-Order递归解法:  Time O(n)<br>(1) 如果二叉树为空，返回<br>(2) 如果二叉树不为空，中序遍历左子树，访问根节点,list.add(root.val), 中序遍历右子树  </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public List<span class="tag">&lt;Integer&gt;</span> inorderTraversal(TreeNode root) &#123;</div><div class="line">	List<span class="tag">&lt;Integer&gt;</span> list = new ArrayList<span class="tag">&lt;&gt;</span>();</div><div class="line">	helper(list, root);</div><div class="line">	return list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void helper(List<span class="tag">&lt;Integer&gt;</span> list, TreeNode <span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>) return;</div><div class="line">	helper(list, <span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">	list.add(<span class="keyword">node</span>.<span class="title">val</span>);</div><div class="line">	helper(list,<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In-Order迭代解法:  Time O(n)<br>(1) 使用Stack, 先把每个需要存入的节点遍历所有左子节点，并全部存入<br>(2) 如果左子树为空，则从stack中输出一个节点，用list依次记录所有输出节点，以此节点向右访问一次右节点，然后重复（1）操作。<br>(3) 特别注意：这里有个tricky的地方，就是一开始是从root节点直接向左遍历，但当我从stack中输出的节点就不需要再向左遍历，所以需要创建两个新的节点，一个代表从stack输出的节点，一个代表向右找到的新节点。只有向右找到的新节点需要左遍历。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;</div><div class="line">	<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">	<span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">	<span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</div><div class="line">	<span class="built_in">stack</span>.push(root);</div><div class="line">	TreeNode node = root;</div><div class="line">	<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;</div><div class="line">			</div><div class="line">		<span class="keyword">while</span>(node.left!=<span class="built_in">null</span>) &#123;</div><div class="line">			<span class="built_in">stack</span>.push(node.left);</div><div class="line">			node = node.left;</div><div class="line">		&#125;</div><div class="line">		TreeNode addNode = <span class="built_in">stack</span>.pop();</div><div class="line">		<span class="built_in">list</span>.add(addNode.val);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(addNode.right!=<span class="built_in">null</span>) &#123;</div><div class="line">			<span class="built_in">stack</span>.push(addNode.right);</div><div class="line">			node = addNode.right;</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LeetCode - 145.Binary Tree Postorder Traversal<br>Post-Order递归解法:  Time O(n)<br>(1) 如果二叉树为空，返回<br>(2) 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点,list.add(root.val)</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public List<span class="tag">&lt;Integer&gt;</span> postorderTraversalRec(TreeNode root) &#123;</div><div class="line">	List<span class="tag">&lt;Integer&gt;</span> list = new ArrayList<span class="tag">&lt;&gt;</span>();</div><div class="line">	helper(list, root);</div><div class="line">	return list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void helper(List<span class="tag">&lt;Integer&gt;</span> list, TreeNode <span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>) return;</div><div class="line">	helper(list, <span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">	helper(list, <span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">	list.add(<span class="keyword">node</span>.<span class="title">val</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Post-Order迭代解法:<br>解法一：<br>(1) 使用双栈法，使用先序遍历的反向逆转<br>(2) 首先先序遍历是：<code>self, left, right</code>, 反向先序遍历为<code>self, right, left</code>, 在使用另一个stack逆转为<code>left, right, self</code> 即为后序遍历</p>
<p>解法二：<br>(1) 解法像pre-order,stack先压人root，然后压入右节点再压入左节点<br>(2) 有两种情况需要从stack中压出节点并添加到list中，一是左右节点为null，二是左右的节点都被访问过。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//Solution1: Two stack</div><div class="line">public List<span class="tag">&lt;Integer&gt;</span> postorderTraversal(TreeNode root) &#123;</div><div class="line">	List<span class="tag">&lt;Integer&gt;</span> list = new ArrayList<span class="tag">&lt;&gt;</span>();</div><div class="line">	if(root == null) return list;</div><div class="line">	Stack<span class="tag">&lt;TreeNode&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</div><div class="line">	Stack<span class="tag">&lt;TreeNode&gt;</span> reverseStack = new Stack<span class="tag">&lt;&gt;</span>();</div><div class="line">	stack.push(root);</div><div class="line">	while(!stack.isEmpty()) &#123;</div><div class="line">		TreeNode <span class="keyword">node</span> <span class="title">= stack</span>.pop();</div><div class="line">		reverseStack.push(<span class="keyword">node</span><span class="title">);</span></div><div class="line">		if(<span class="keyword">node</span>.<span class="title">left</span>!=null) stack.push(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">		if(<span class="keyword">node</span>.<span class="title">right</span>!=null) stack.push(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">	&#125;</div><div class="line">	while(!reverseStack.isEmpty()) &#123;</div><div class="line">		list.add(reverseStack.pop());</div><div class="line">	&#125;</div><div class="line">	return list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Solution2: </div><div class="line">public List<span class="tag">&lt;Integer&gt;</span> postorderTraversal(TreeNode root) &#123;</div><div class="line">	List<span class="tag">&lt;Integer&gt;</span> list = new ArrayList<span class="tag">&lt;&gt;</span>();</div><div class="line">	if(root == null) return list;</div><div class="line">	Stack<span class="tag">&lt;TreeNode&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</div><div class="line">	stack.push(root);</div><div class="line">	TreeNode prev = null;</div><div class="line">	while(!stack.isEmpty()) &#123;</div><div class="line">		TreeNode <span class="keyword">node</span> <span class="title">= stack</span>.peek();</div><div class="line">		//<span class="keyword">node</span>.<span class="title">left</span>==null &amp;&amp; <span class="keyword">node</span>.<span class="title">right</span>==null表明<span class="keyword">node</span><span class="title">为叶节点</span></div><div class="line">		//prev!=null &amp;&amp; <span class="attr">prev=</span>=<span class="keyword">node</span>.<span class="title">left</span> 表明左子树遍历完，右子树为空</div><div class="line">		//prev!=null &amp;&amp; <span class="attr">prev=</span>=<span class="keyword">node</span>.<span class="title">right</span> 表明右子树遍历完</div><div class="line">		//prev!=<span class="keyword">node</span>.<span class="title">left</span>&amp;&amp;prev!=<span class="keyword">node</span>.<span class="title">right</span>表明stack已经连续输出节点到另一分支</div><div class="line">		if((<span class="keyword">node</span>.<span class="title">left</span>==null &amp;&amp; <span class="keyword">node</span>.<span class="title">right</span>==null)||(prev!=null &amp;&amp; (prev == <span class="keyword">node</span>.<span class="title">left</span> || <span class="attr">prev=</span>=<span class="keyword">node</span>.<span class="title">right</span>))) &#123;</div><div class="line">			<span class="keyword">node</span> <span class="title">= stack</span>.pop();</div><div class="line">			list.add(<span class="keyword">node</span>.<span class="title">val</span>);</div><div class="line">			prev = <span class="keyword">node</span><span class="title">;</span></div><div class="line">		&#125;else &#123;</div><div class="line">			if(<span class="keyword">node</span>.<span class="title">right</span>!=null) stack.push(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">			if(<span class="keyword">node</span>.<span class="title">left</span>!=null) stack.push(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line">	return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.分层遍历二叉树（按层次从上往下，从左往右）: levelTraversal, levelTraversalRec（递归解法）</p>
<p>LeetCode - 102.Binary Tree Level Order Traversal </p>
<p>递归解法：<br>记录每层个数，用层数去比较大lists的size，如果size等于层数，则需要添加一个新的list用于记录当前层的nodes，如果size小于层数，则拿出lists中相对应层数的list去添加nodes.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">	<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; lists = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">	helper(lists, root,<span class="number">0</span>);</div><div class="line">	<span class="keyword">return</span> lists;</div><div class="line">&#125;</div><div class="line"><span class="literal">void</span> helper(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; lists, TreeNode node, int level) &#123;</div><div class="line">	<span class="keyword">if</span>(node == <span class="built_in">null</span>) <span class="keyword">return</span>;</div><div class="line">	<span class="comment">//add a new list to the new level of nodes</span></div><div class="line">	<span class="keyword">if</span>(lists.size() == level) lists.add(<span class="literal">new</span> ArrayList&lt;<span class="built_in">Integer</span>&gt;());</div><div class="line">	<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; temp = lists.get(level);</div><div class="line">	temp.add(node.val);</div><div class="line">	helper(lists, node.left,level+<span class="number">1</span>);</div><div class="line">	helper(lists, node.right,level+<span class="number">1</span>);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代解法：<br>使用Queue实现BFS</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Traverse tree use BFS</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> levelTraversal(TreeNode root) &#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	queue.<span class="built_in">add</span>(root);</div><div class="line">	<span class="keyword">while</span>(!queue.isEmpty()) &#123;</div><div class="line">		<span class="built_in">int</span> <span class="built_in">size</span> = queue.<span class="built_in">size</span>();</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++) &#123;</div><div class="line">			TreeNode node = queue.poll();</div><div class="line">			<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.<span class="built_in">add</span>(node.left);</div><div class="line">			<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.<span class="built_in">add</span>(node.right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5.将二叉查找树变为有序的双向链表: convertBST2DLLRec, convertBST2DLL</p>
<p>LeetCode - 114.Flatten Binary Tree to Linked List </p>
<p>递归解法：<br>(1) 如果二叉树为空，返回<br>(2) 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点, 把根节点的左子树移到右边，左边致为null,把根节点的原右子树放到原左子树的最右边</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> void flatten(TreeNode root) &#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) return;</div><div class="line">	</div><div class="line">	flatten(root.<span class="built_in">left</span>);</div><div class="line">	flatten(root.<span class="built_in">right</span>);</div><div class="line">	</div><div class="line">	TreeNode <span class="built_in">right</span> = root.<span class="built_in">right</span>;</div><div class="line">	root.<span class="built_in">right</span> = root.<span class="built_in">left</span>;</div><div class="line">	root.<span class="built_in">left</span> = <span class="literal">null</span>;</div><div class="line">	TreeNode cur = root;</div><div class="line">	<span class="keyword">while</span>(cur.<span class="built_in">right</span>!=<span class="literal">null</span>) cur = cur.<span class="built_in">right</span>;</div><div class="line">	cur.<span class="built_in">right</span> = <span class="built_in">right</span>;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代解法： </p>
<ol>
<li>依次遍历右节点</li>
<li>每次把current node 的右子树放到左子树的最右边，然后把左子树放到右边之后，把左边致为null</li>
</ol>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> void flatten(TreeNode root) &#123;</div><div class="line">		<span class="keyword">if</span>(root == <span class="literal">null</span>) return;</div><div class="line">		<span class="keyword">while</span>(root!=<span class="literal">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span>(root.<span class="built_in">left</span>==<span class="literal">null</span>)&#123;</div><div class="line">				root = root.<span class="built_in">right</span>;</div><div class="line">				continue;</div><div class="line">			&#125;</div><div class="line">			TreeNode <span class="built_in">left</span> = root.<span class="built_in">left</span>;</div><div class="line">			<span class="keyword">while</span>(<span class="built_in">left</span>.<span class="built_in">right</span>!=<span class="literal">null</span>) &#123;</div><div class="line">				<span class="built_in">left</span> = <span class="built_in">left</span>.<span class="built_in">right</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">left</span>.<span class="built_in">right</span> = root.<span class="built_in">right</span>;</div><div class="line">			root.<span class="built_in">right</span> = root.<span class="built_in">left</span>;</div><div class="line">			root.<span class="built_in">left</span> = <span class="literal">null</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>6.求二叉树第K层的节点个数：getNodeNumKthLevelRec, getNodeNumKthLevel<br>递归解法：即把问题分解的过程<br>(1) 如果current node为null 或者 k为0，返回0.<br>(2) 如果二叉树不为空且k为1，则返回1.<br>(3) 如果二叉树不为空且k&gt;1, 则返回 左子树+右子树 的个数.</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getNodeNumKthLevel</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span> || k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span>  getNodeNumKthLevel(root.left,k<span class="number">-1</span>) + getNodeNumKthLevel(root.right,k<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代解法： </p>
<ol>
<li>使用BFS, 用Queue去存储每一层节点</li>
<li>返回某层节点数，即size of Queue</li>
</ol>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Traverse tree use BFS</span></div><div class="line"><span class="keyword">public</span> <span class="built_in">int</span> getNodeNumKthLevel(TreeNode root, <span class="built_in">int</span> k) &#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	<span class="built_in">int</span> count = <span class="number">0</span>;</div><div class="line">	queue.<span class="built_in">add</span>(root);</div><div class="line">	<span class="built_in">int</span> result = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(!queue.isEmpty()) &#123;</div><div class="line">		<span class="built_in">int</span> <span class="built_in">size</span> = queue.<span class="built_in">size</span>();</div><div class="line">		<span class="keyword">if</span>(--k == <span class="number">0</span>)&#123;</div><div class="line">			result = <span class="built_in">size</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++) &#123;</div><div class="line">			TreeNode node = queue.poll();</div><div class="line">			<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.<span class="built_in">add</span>(node.left);</div><div class="line">			<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.<span class="built_in">add</span>(node.right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>7.求二叉树中叶子节点的个数：getNodeNumLeafRec, getNodeNumLeaf<br>递归解法：即把问题分解的过程<br>(1) 如果二叉树为null，返回0<br>(2) 如果二叉树不为空且其左右子树均为null，则返回1. 叶子数 = 左子树叶子数 + 右子树叶子数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> int getNodeNumLeafRec(TreeNode root) &#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(root.right==<span class="literal">null</span> &amp;&amp; root.left==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span>  getNodeNumLeafRec(root.left) + getNodeNumLeafRec(root.right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代解法： </p>
<ol>
<li>使用BFS, 用Queue去存储每一层节点</li>
<li>判断每个node是否含有左子树和右子树，如果没有则 叶子数+1</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Traverse tree use BFS</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> getNodeNumKthLevel(TreeNode root) &#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	<span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</div><div class="line">	queue.add(root);</div><div class="line">	<span class="keyword">while</span>(!queue.isEmpty()) &#123;</div><div class="line">		<span class="keyword">int</span> <span class="keyword">size</span> = queue.<span class="keyword">size</span>();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">size</span>;i++) &#123;</div><div class="line">			TreeNode node = queue.poll();</div><div class="line">			<span class="keyword">if</span>(node.left==<span class="keyword">null</span> &amp;&amp; node.right==<span class="keyword">null</span>)<span class="keyword">count</span>++;</div><div class="line">			<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</div><div class="line">			<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>8.判断两棵二叉树是否相同的树：isSameRec, isSame</p>
<p>LeetCode - 100.Same Tree     </p>
<p>递归解法：<br>(1) 如果两个树都为空，返回true. 如果其中有一个节点为空或者两个节点的值不等，返回false.<br>(2) 递归遍历左子树和右子树，重复（1）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> boolean isSameTree(TreeNode p, TreeNode q) &#123;</div><div class="line">	<span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>(p==<span class="literal">null</span> || q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">if</span>(p.<span class="keyword">val</span>!=q.<span class="keyword">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">if</span>(p.<span class="keyword">val</span>==q.<span class="keyword">val</span>) <span class="keyword">return</span> isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代解法： </p>
<ol>
<li>对两个树同时使用先序遍历</li>
<li>每次比较两个点</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isSameTree(TreeNode p, TreeNode q) &#123;		<span class="keyword">if</span>(p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">if</span>(p==<span class="keyword">null</span> || q==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">		Stack&lt;TreeNode&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">		s1.<span class="keyword">push</span>(p);</div><div class="line">		s2.<span class="keyword">push</span>(q);</div><div class="line">		<span class="keyword">while</span>(!s1.isEmpty() &amp;&amp; !s2.isEmpty()) &#123;</div><div class="line">			TreeNode node1 = s1.<span class="keyword">pop</span>();</div><div class="line">			TreeNode node2 = s2.<span class="keyword">pop</span>();</div><div class="line">			<span class="keyword">if</span>(node1==<span class="keyword">null</span> &amp;&amp; node2==<span class="keyword">null</span>) <span class="keyword">continue</span>;</div><div class="line">			<span class="keyword">if</span>(node1!=<span class="keyword">null</span> &amp;&amp; node2!=<span class="keyword">null</span> &amp;&amp; node1.val==node2.val) &#123;</div><div class="line">				s1.<span class="keyword">push</span>(node1.left);</div><div class="line">				s1.<span class="keyword">push</span>(node1.right);</div><div class="line">				s2.<span class="keyword">push</span>(node2.left);</div><div class="line">				s2.<span class="keyword">push</span>(node2.right);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;	</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;	</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>9.判断二叉树是不是平衡二叉树：isBalanced </p>
<p>LeetCode - 110.Balanced Binary Tree</p>
<p>递归解法1：O(NlogN)<br>遍历每个点，每次都比较其左子树和右子树的高度 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> boolean isBalanced(<span class="type">TreeNode</span> root) &#123;</div><div class="line">	<span class="keyword">if</span>(root==null) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>(<span class="type">Math</span>.<span class="built_in">abs</span>(getDepth(root.<span class="keyword">left</span>)-getDepth(root.<span class="keyword">right</span>))&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">return</span> isBalanced(root.<span class="keyword">left</span>) &amp;&amp; isBalanced(root.<span class="keyword">right</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int getDepth(<span class="type">TreeNode</span> node) &#123;</div><div class="line">	<span class="keyword">if</span>(node==null) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="type">Math</span>.<span class="built_in">max</span>(getDepth(node.<span class="keyword">left</span>),getDepth(node.<span class="keyword">right</span>))+<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>递归解法2： </p>
<ol>
<li>自下而上，每次比较左子树和右子树，如果两边高度大于1，则返回-1。如果不是，则返回高度，供父节点使用。</li>
<li>如果有一边是-1，就直接向上，不用再求高度。</li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;			<span class="keyword">if</span>(getDepth(root)==<span class="number">-1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode node)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> leftDepth = getDepth(node.left);</div><div class="line">		<span class="keyword">if</span>(leftDepth==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> rightDepth = getDepth(node.right);</div><div class="line">		<span class="keyword">if</span>(rightDepth==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> diff = Math.abs(leftDepth-rightDepth);</div><div class="line">		<span class="keyword">if</span>(diff&gt;<span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> Math.max(leftDepth,rightDepth) + <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>10.求二叉树的镜像（破坏和不破坏原来的树两种情况）：<br>     mirrorRec, mirrorCopyRec<br>     mirror, mirrorCopy   </p>
<p>破坏原来的树<br>递归解法：<br>(1) 如果二叉树为空，返回null.<br>(2) 如果二叉树不为空, 无论有没有左右子树，交换他们的位置. 即自底向上依次调换所有左右子树位置。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="type">TreeNode</span> mirrorRec(<span class="type">TreeNode</span> root) &#123;</div><div class="line">	<span class="keyword">if</span>(root==null) <span class="keyword">return</span> null;</div><div class="line">	<span class="type">TreeNode</span> <span class="keyword">left</span> = mirrorRec(root.<span class="keyword">left</span>);</div><div class="line">	<span class="type">TreeNode</span> <span class="keyword">right</span> = mirrorRec(root.<span class="keyword">right</span>);</div><div class="line">	root.<span class="keyword">right</span> = <span class="keyword">left</span>;</div><div class="line">	root.<span class="keyword">left</span> = <span class="keyword">right</span>;</div><div class="line">	<span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代解法：<br>使用BFS,每次遍历一个点都交换它左右子树的位置 </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public TreeNode mirror(TreeNode root) &#123;</div><div class="line">	if(root == null) return null;</div><div class="line">	Queue<span class="tag">&lt;TreeNode&gt;</span> queue = new LinkedList<span class="tag">&lt;&gt;</span>();</div><div class="line">	queue.add(root);</div><div class="line">	while(!queue.isEmpty()) &#123;</div><div class="line">		TreeNode <span class="keyword">node</span> <span class="title">= queue</span>.poll();</div><div class="line">		if(<span class="keyword">node</span>.<span class="title">left</span>==null &amp;&amp; <span class="keyword">node</span>.<span class="title">right</span>==null) continue;</div><div class="line">		TreeNode left = <span class="keyword">node</span>.<span class="title">left</span>;</div><div class="line">		<span class="keyword">node</span>.<span class="title">left</span> = <span class="keyword">node</span>.<span class="title">right</span>;</div><div class="line">		<span class="keyword">node</span>.<span class="title">right</span> = left;</div><div class="line">		if(<span class="keyword">node</span>.<span class="title">left</span>!=null) queue.add(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">		if(<span class="keyword">node</span>.<span class="title">right</span>!=null) queue.add(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	return root;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不破坏原来的树<br>递归解法：<br>(1) 如果二叉树为空，返回null.<br>(2) 如果二叉树不为空, 使用先序遍历，首先创建新的节点，然后左右颠倒构造新的二叉树</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> TreeNode mirrorCopyRec(TreeNode root) &#123;</div><div class="line">	<span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;	</div><div class="line">	TreeNode newRoot = new TreeNode(root.<span class="keyword">val</span>);</div><div class="line">	newRoot.left = mirrorRec(root.right);</div><div class="line">	newRoot.right = mirrorRec(root.left);</div><div class="line">	<span class="keyword">return</span> newRoot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代解法：<br>使用Pre-Order, 保持两个stack，使新创建的点与原来的树保持一一对应. </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public TreeNode mirror(TreeNode root) &#123;</div><div class="line">	if(root == null) return null;</div><div class="line">	Stack<span class="tag">&lt;TreeNode&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</div><div class="line">	Stack<span class="tag">&lt;TreeNode&gt;</span> newStack = new Stack<span class="tag">&lt;&gt;</span>();</div><div class="line">	stack.push(root);</div><div class="line">	TreeNode newRoot = new TreeNode(root.val);</div><div class="line">	newStack.push(newRoot);</div><div class="line">	while(!queue.isEmpty()) &#123;</div><div class="line">		TreeNode <span class="keyword">node</span> <span class="title">= stack</span>.pop();</div><div class="line">		TreeNode newNode = newStack.pop();</div><div class="line">		if(<span class="keyword">node</span>.<span class="title">left</span>!=null) &#123;</div><div class="line">			stack.push(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">			newNode.rihgt = newTreeNode(<span class="keyword">node</span>.<span class="title">left</span>.val);</div><div class="line">			stack.push(newNode.right);</div><div class="line">		&#125; </div><div class="line">		if(<span class="keyword">node</span>.<span class="title">right</span>!=null) &#123;</div><div class="line">			stack.push(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">			newNode.left = newTreeNode(<span class="keyword">node</span>.<span class="title">right</span>.val);</div><div class="line">			stack.push(newNode.left);</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line">	return newRoot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>10.1 判断两个树是否互相镜像：isMirrorRec isMirror</p>
<p>递归解法：<br>(1) 如果两个二叉树都为空，返回true.<br>(2) 如果只有其中一个二叉树为空，返回false.<br>(3) 若果两个节点的val不相等，返回false.<br>(4) 比较一个树的左子树和另个树的右子树，以及一个树的右子树和另个树的左子树.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> boolean isMirrorRec(TreeNode p, TreeNode q) &#123;</div><div class="line">	<span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>; </div><div class="line">	<span class="keyword">if</span>(p==<span class="literal">null</span> || q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">if</span>(p.<span class="keyword">val</span> != q.<span class="keyword">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">return</span> isMirrorRec(p.left,q.right) &amp;&amp; isMirrorRec(p.right,q.left);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代解法：<br>使用Pre-Order,每次遍历交叉树的值</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isMirror(TreeNode p, TreeNode q) &#123;</div><div class="line">	<span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">if</span>(p == <span class="keyword">null</span> || q==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">	Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">	stack1.<span class="keyword">push</span>(p);</div><div class="line">	stack2.<span class="keyword">push</span>(q);</div><div class="line">	<span class="keyword">while</span>(!p.isEmpty()&amp;&amp;!q.isEmpty()) &#123;</div><div class="line">		TreeNode node1 = stack1.<span class="keyword">pop</span>();</div><div class="line">		TreeNode node2 = stack2.<span class="keyword">pop</span>();</div><div class="line">		<span class="keyword">if</span>(node1.val != node.val) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">if</span>((node1.left==<span class="keyword">null</span>&amp;&amp;node2.rihgt!=<span class="keyword">null</span>)||(node1.left!=<span class="keyword">null</span>&amp;&amp;node2.rihgt==<span class="keyword">null</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">if</span>(node1.left!=<span class="keyword">null</span> &amp;&amp; node2.right!=<span class="keyword">null</span>) &#123;</div><div class="line">			stack1.<span class="keyword">push</span>(node1.left);</div><div class="line">			stack2.<span class="keyword">push</span>(node2.right);</div><div class="line">		&#125; </div><div class="line">		<span class="keyword">if</span>((node1.rihgt==<span class="keyword">null</span>&amp;&amp;node2.left!=<span class="keyword">null</span>)||(node1.right!=<span class="keyword">null</span>&amp;&amp;node2.left==<span class="keyword">null</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">if</span>(node1.rihgt!=<span class="keyword">null</span> &amp;&amp; node2.left!=<span class="keyword">null</span>) &#123;</div><div class="line">			stack1.<span class="keyword">push</span>(node1.right);</div><div class="line">			stack2.<span class="keyword">push</span>(node2.left);</div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>11.求二叉树中两个节点的最低公共祖先节点：<br>       getLastCommonParent    求解最小公共祖先, 使用list来存储path.<br>       getLastCommonParentRec     递归算法 .      </p>
<p>LeetCode - 236.Lowest Common Ancestor of a Binary Tree    </p>
<p>递归解法：<br>(1) 如果从根节点出发，分别从左右两边找到两个节点，则LastCommonParrent是根节点<br>(2) 如果从根节点的左子树出发，找到两节点，则LastCommonParrent在左子树<br>(3) 如果从根节点的右子树出发，找到两节点，则LastCommonParrent在右子树</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">	<span class="comment">//Solution1:</span></div><div class="line">	<span class="keyword">public</span> TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) &#123;</div><div class="line">		<span class="keyword">if</span>(findNode(root.left,p)) &#123;</div><div class="line">			<span class="keyword">if</span>(findNode(root.left,q)) &#123;</div><div class="line">				<span class="keyword">return</span> getLastCommonParentRec(root.left,p,q);</div><div class="line">			&#125;<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> root;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span>(findNode(root.right,q)) &#123;</div><div class="line">				<span class="keyword">return</span> getLastCommonParentRec(root.right,p,q);</div><div class="line">			&#125;<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> root;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	boolean findNode(TreeNode root, TreeNode node) &#123;</div><div class="line">		<span class="keyword">if</span>(root==<span class="literal">null</span> || node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(root==node) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		</div><div class="line">		boolean found = findNode(root.left,node);</div><div class="line">		<span class="keyword">if</span>(!found) &#123;</div><div class="line">			found = findNode(root.right,node);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> found;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//Solution2:</span></div><div class="line"><span class="keyword">public</span> TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) &#123;</div><div class="line">	<span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">	<span class="keyword">if</span>(root==p || root==q) <span class="keyword">return</span> root;</div><div class="line">	TreeNode commonLeft = getLastCommonParentRec(root.left,p,q);</div><div class="line">	TreeNode commonRight = getLastCommonParentRec(root.right,p,q);</div><div class="line">	<span class="keyword">if</span>(commonLeft!=<span class="literal">null</span> &amp;&amp; commonRight!=<span class="literal">null</span>) <span class="keyword">return</span> root;</div><div class="line">	<span class="keyword">if</span>(commonLeft!=<span class="literal">null</span>) <span class="keyword">return</span> commonLeft;</div><div class="line">	<span class="keyword">return</span> commonRight;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代解法： </p>
<ol>
<li>分别从根节点出发，查找到达两个节点的路径，用list保存</li>
<li>然后同时比较两个list中的点，找出最后相同的两个点（两个list前面的点都相同）</li>
</ol>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) &#123;</div><div class="line">	ArrayList&lt;TreeNode&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	ArrayList&lt;TreeNode&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	<span class="built_in">boolean</span> found1 = findPath(root,p,list1);</div><div class="line">	<span class="built_in">boolean</span> found2 = findPath(root,q,list2);</div><div class="line">	<span class="keyword">if</span>(!found1 || !found2) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	</div><div class="line">	TreeNode result = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;Math.<span class="built_in">min</span>(list1.<span class="built_in">size</span>(),list2.<span class="built_in">size</span>());i++) &#123;</div><div class="line">		<span class="keyword">if</span>(list1.<span class="built_in">get</span>(i)==list2.<span class="built_in">get</span>(i))&#123;</div><div class="line">			result = list1.<span class="built_in">get</span>(i);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">boolean</span> findPath(TreeNode root, TreeNode node, ArrayList&lt;TreeNode&gt; list) &#123;</div><div class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span> || node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	list.<span class="built_in">add</span>(root);</div><div class="line">	<span class="keyword">if</span>(root == node) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="built_in">boolean</span> found = findPath(root.left,node,list);</div><div class="line">	<span class="keyword">if</span>(!found) &#123;</div><div class="line">		found = findPath(root.right,node,list);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(!found) list.remove(root);</div><div class="line">	<span class="keyword">return</span> found;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>12.求二叉树中节点的最大距离：getMaxDistanceRec     </p>
<p>递归法：<br>(1)求最大距离有两种情况：一是两个最大深度相加，它分别位于根节点的两侧；一是某个子节点下两个分支距离的和最大<br>(2)创建一个类去记录最大距离和最大深度，每次记录每个点的深度，以及最长距离</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxDistanceRec</span>(<span class="params">TreeNode root</span>) </span>&#123;</div><div class="line">	Distance dis = getDistance(root);</div><div class="line">	<span class="keyword">return</span> dis.maxDistance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Distance <span class="title">getDistance</span>(<span class="params">TreeNode node</span>) </span>&#123;</div><div class="line">	<span class="comment">//最底一层，深度为0</span></div><div class="line">	<span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</div><div class="line">		Distance empty = <span class="keyword">new</span> Distance(<span class="number">0</span>,<span class="number">-1</span>);</div><div class="line">		<span class="keyword">return</span> empty;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	Distance left = getDistance(node.left);</div><div class="line">	Distance right = getDistance(node.right);</div><div class="line">	</div><div class="line">	Distance dis = <span class="keyword">new</span> Distance();</div><div class="line">	dis.maxDepth = Math.max(left.maxDepth,right.maxDepth)+<span class="number">1</span>;</div><div class="line">	dis.maxDistance = Math.max(left.maxDepth+right.maxDepth+<span class="number">2</span>,Math.max(left.maxDistance,right.maxDistance));</div><div class="line">	<span class="keyword">return</span> dis;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">Distance</span> &#123;</div><div class="line">	<span class="keyword">int</span> maxDistance;</div><div class="line">	<span class="keyword">int</span> maxDepth;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Distance</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Distance</span>(<span class="params"><span class="keyword">int</span> maxDistance,<span class="keyword">int</span> maxDepth</span>)</span>&#123;</div><div class="line">		<span class="keyword">this</span>.maxDistance = maxDistance;</div><div class="line">		<span class="keyword">this</span>.maxDepth = maxDepth;</div><div class="line">	&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>13.由前序遍历序列和中序遍历序列重建二叉树：rebuildBinaryTreeRec</p>
<p>LeetCode - 105. Construct Binary Tree from Preorder and Inorder Traversal     </p>
<p>递归解法：</p>
<ol>
<li>由前序遍历可以知道第一个点是root，接下来几个点是左子树的点，之后几个是右子树的点, 特点是大体排列次序按照每个树的根节点顺序排列。</li>
<li>由中序遍历可以知道root点左边的都是左子树的点，右边都是右子树的点.可以得出左子树和右子树节点数</li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function">TreeNode <span class="title">rebuildBinaryTreeRec</span><span class="params">(<span class="keyword">int</span>[]preorder,<span class="keyword">int</span>[]inorder)</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">return</span> <span class="title">buildTree</span><span class="params">(preorder,<span class="number">0</span>,preorder.length<span class="number">-1</span>,inorder,<span class="number">0</span>,inorder.length<span class="number">-1</span>)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[]preorder,<span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[]inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(preStart &gt; preEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">int</span> rootVal = preorder[preStart];</div><div class="line">	<span class="keyword">int</span> inRoot=<span class="number">-1</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=inStart,j=inEnd; i&lt;=j; i++,j--) &#123;</div><div class="line">		<span class="keyword">if</span>(inorder[i] == rootVal) &#123;</div><div class="line">			inRoot = i;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(inorder[j] == rootVal)</span></span>&#123;</div><div class="line">			inRoot = j;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125; </div><div class="line">	TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</div><div class="line">	root.left = buildTree(preorder,preStart+<span class="number">1</span>,preStart+(inRoot-inStart), inorder,inStart,inRoot<span class="number">-1</span>);</div><div class="line">	root.right = buildTree(preorder,preEnd-(inEnd-inRoot)+<span class="number">1</span>,preEnd,inorder,inRoot+<span class="number">1</span>,inEnd);</div><div class="line">	<span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>14.判断二叉树是不是完全二叉树：isCompleteBinaryTree, isCompleteBinaryTreeRec</p>
<p>迭代解法：<br>(1)使用BFS遍历节点，每层节点中，如果遇到左右子树为空时，或者遇到的第一个左子树不为空但右子树为空的情况，则后面所有的左右子树必须为空。即为完全二叉树。<br>(2)设立一个标志，如果有个节点的左右子树为空，则之后所有节点的子树必须为空。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public boolean isCompleteBinaryTree(TreeNode root) &#123;</div><div class="line">	if(root == null) return <span class="literal">false</span>;</div><div class="line">	Queue<span class="tag">&lt;TreeNode&gt;</span> queue = new Queue<span class="tag">&lt;&gt;</span>();</div><div class="line">	queue.add(root);</div><div class="line">	boolean flag = <span class="literal">true</span>;</div><div class="line">	while(!queue.isEmpty()) &#123;</div><div class="line">		TreeNode <span class="keyword">node</span> <span class="title">= queue</span>.poll();</div><div class="line">		if(flag) &#123;</div><div class="line">			if(<span class="keyword">node</span>.<span class="title">left</span>==null &amp;&amp; <span class="keyword">node</span>.<span class="title">right</span>==null) flag = <span class="literal">false</span>;</div><div class="line">			else if(<span class="keyword">node</span>.<span class="title">left</span>==null &amp;&amp; <span class="keyword">node</span>.<span class="title">right</span>!=null) return <span class="literal">false</span>;</div><div class="line">			else if(<span class="keyword">node</span>.<span class="title">left</span>!=null &amp;&amp; <span class="keyword">node</span>.<span class="title">right</span>==null) &#123;</div><div class="line">				flag = <span class="literal">false</span>;</div><div class="line">				queue.add(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">			&#125;else &#123;</div><div class="line">				queue.add(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">				queue.add(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;else &#123;</div><div class="line">			if(<span class="keyword">node</span>.<span class="title">left</span>!=null || <span class="keyword">node</span>.<span class="title">right</span>!=null) return <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return <span class="literal">true</span>;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>15.找出二叉树中最长连续子串(即全部往左的连续节点，或是全部往右的连续节点）findLongest</p>
<h2 id="学习后总结："><a href="#学习后总结：" class="headerlink" title="学习后总结："></a>学习后总结：</h2><h3 id="When-to-use-Pre-Order-In-Order-Post-Order"><a href="#When-to-use-Pre-Order-In-Order-Post-Order" class="headerlink" title="When to use Pre-Order, In-Order, Post-Order"></a>When to use Pre-Order, In-Order, Post-Order</h3><ul>
<li>Pre-Order: Recursively, this is <code>self, left, right</code>. From root node to right most node. Firstly, if you know you need to explore the roots before inspecting any leaves, you should pick pre-order because you will encounter all the roots before all of the leaves.  Secondly, if you want to simply print out the hierachical format of the tree in a linear format, use preorder traversal.</li>
</ul>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"> Root</span></div><div class="line">    -<span class="ruby"> A</span></div><div class="line">    	-<span class="ruby"> B</span></div><div class="line">    	-<span class="ruby"> C</span></div><div class="line">    -<span class="ruby"> D</span></div><div class="line">    	-<span class="ruby"> E</span></div><div class="line">    	-<span class="ruby"> F</span></div><div class="line">    		-<span class="ruby">G</span></div></pre></td></tr></table></figure>
<ul>
<li>Post-Order: Recursively, this is<code>left, right, self</code>. From left most node to right most node.  If you know you need to explore all the leaves before any nodes, you should pick post-order because you don’t waster any time inspecting roots in search for leaves. 或者应用在：树的删除。为了释放树结构的内存，某节点在被释放以前，其左右子树的节点首先应当被释放掉。</li>
<li>In-Order: Recursively, this is<code>left, self, right</code>. From left most node to right most node. If you know that the tree has an inherent sequence, and you want to flatten the tree back into the original sequence(simply process the items in the defined order).  </li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">For example, you have <span class="keyword">a</span> BST <span class="keyword">of</span> <span class="keyword">a</span> list <span class="keyword">of</span> <span class="built_in">number</span>, inorder traversal would print them out <span class="keyword">in</span> <span class="keyword">ascending</span> order.</div><div class="line"></div><div class="line">	+</div><div class="line">  /	  \ </div><div class="line"> A     * </div><div class="line">	  /  \</div><div class="line">	 B    C</div><div class="line"></div><div class="line">Output: A + B * C</div><div class="line"></div><div class="line">If you want <span class="built_in">to</span> evaluate <span class="keyword">the</span> expression, you traverse <span class="keyword">the</span> tree <span class="keyword">in</span> postorder, applying <span class="keyword">each</span> operator <span class="built_in">to</span> <span class="keyword">the</span> values <span class="built_in">from</span> <span class="keyword">each</span> <span class="keyword">of</span> its sub-trees.</div></pre></td></tr></table></figure>
<h3 id="When-to-use-BFS-and-DFS-the-relationship-between-DFS-and-PreOrder"><a href="#When-to-use-BFS-and-DFS-the-relationship-between-DFS-and-PreOrder" class="headerlink" title="When to use BFS and DFS, the relationship between DFS and PreOrder"></a>When to use BFS and DFS, the relationship between DFS and PreOrder</h3><p>DFS 包括: </p>
<ol>
<li>Pre-Order, In-Order, Post-Order</li>
<li>Divide &amp; Conquer</li>
</ol>
<p>Notice：<br>Sometimes it is easy to figure out question using Recursion.  So interviewer wants you to use Iterative solution.  因为这里，递归的方法和变量都是存储在Stack中的，现在就是想考验你去实现栈的内部工作原理，使用iteration 都需要去借助一个数据结构来完成recursion的方法。</p>
<p>DFS Template:</p>
<p>1.Recursively Traverse</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(roo==<span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">	</div><div class="line">	traversal(root.left);</div><div class="line">	</div><div class="line">	traversal(root.right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.Divide &amp; Conquer</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="type">ResultType</span> traversal(<span class="type">TreeNode</span> root) &#123;</div><div class="line">	<span class="keyword">if</span>(root==null) &#123;</div><div class="line">		<span class="keyword">return</span> null;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//Divide</span></div><div class="line">	<span class="type">ResultType</span> <span class="keyword">left</span> = traversal(root.<span class="keyword">left</span>);</div><div class="line">	<span class="type">ResultType</span> <span class="keyword">right</span> = traversal(root.<span class="keyword">right</span>);</div><div class="line">	</div><div class="line">	<span class="comment">//Conquer</span></div><div class="line">	<span class="type">ResultType</span> result = <span class="type">Merge</span> from <span class="keyword">left</span> to <span class="keyword">right</span></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="How-to-think-over-Divide-amp-Conquer"><a href="#How-to-think-over-Divide-amp-Conquer" class="headerlink" title="How to think over Divide&amp;Conquer"></a>How to think over Divide&amp;Conquer</h3></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://xinli90.com/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/" data-id="cj64h1cx6003nmgz6r7u6ne0p" class="article-share-link">Share</a><div class="tags"><a href="/tags/Seeking-Job/">Seeking Job</a></div><div class="post-nav"><a href="/2016/08/22/Day10-Algorithm-about-Itetation-and-Recursion/" class="pre">Day10 Algorithm about Itetation and Recursion</a><a href="/2016/08/19/Two-Sum-III-Data-structure-design/" class="next">Two Sum III - Data structure design</a></div><div id="disqus_thread"><script>var disqus_shortname = 'xinli';
var disqus_identifier = '2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/';
var disqus_title = 'Day9 Algorithm about Binary Tree';
var disqus_url = 'http://xinli90.com/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//xinli.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://xinli90.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Seeking-Job/" style="font-size: 15px;">Seeking Job</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/J2EE/" style="font-size: 15px;">J2EE</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AWS/">AWS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure/">Data Structure</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Design-Pattern/">Design Pattern</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Geek/">Geek</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/J2EE/">J2EE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">116</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Multithreading/">Multithreading</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/class-design/">class design</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/2017-Learning02-HTTP-Security/">2017 Learning02 HTTP Security</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/Shopping-Offers/">Shopping Offers</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/Meeting-Rooms/">Meeting Rooms</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/N-Queens/">N Queens</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/20/Flatten-Nested-List-Iterator/">Flatten Nested List Iterator</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/05/One-Edit-Distance/">One Edit Distance</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/05/Read-N-Characters-Given-Read4/">Read N Characters Given Read4</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/03/Maximum-Size-Subarray-Sum-Equals-k/">Maximum Size Subarray Sum Equals k</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/02/Binary-Tree-Vertical-Order-Traversal/">Binary Tree Vertical Order Traversal</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/01/Sparse-Matrix-Multiplication/">Sparse Matrix Multiplication</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//xinli.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="null" title="null" target="_blank"></a><ul></ul><a href="null" title="null" target="_blank"></a><ul></ul><a href="null" title="null" target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Xinli's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-83440669-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>