<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Day9 Algorithm about Binary Search Tree | Xinli's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Day9 Algorithm about Binary Search Tree</h1><a id="logo" href="/.">Xinli's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Day9 Algorithm about Binary Search Tree</h1><div class="post-meta">Aug 22, 2016<span> | </span><span class="category"><a href="/categories/Algorithm-Binary-Search-Tree/">Algorithm, Binary Search Tree</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>本篇是关于二叉树算法的分析和总结。</p>
<h2 id="攻略模板："><a href="#攻略模板：" class="headerlink" title="攻略模板："></a>攻略模板：</h2><ul>
<li>回忆算法特性</li>
<li>实现算法功能</li>
<li>实战训练使用该算法</li>
<li>总结该算法特点，并总结算法题</li>
</ul>
<h4 id="自己回忆："><a href="#自己回忆：" class="headerlink" title="自己回忆："></a>自己回忆：</h4><ul>
<li>一般二叉树的查找可以使用DFS 和 BFS</li>
<li>平衡二叉树可以使用二分法，时间复杂度为O(logn)</li>
<li>二叉树的遍历有先序遍历，中序遍历 和 后序遍历</li>
</ul>
<h4 id="实现算法："><a href="#实现算法：" class="headerlink" title="实现算法："></a>实现算法：</h4><p>在这里我们总结出经典15道二叉树题目： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//Definition for a binary tree node.</div><div class="line">Class TreeNode&#123;</div><div class="line">	int val;</div><div class="line">	TreeNode left;</div><div class="line">	TreeNode right;</div><div class="line">	TreeNode(int x) &#123;</div><div class="line">		val = x;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">```          </div><div class="line"></div><div class="line">1.求二叉树中的节点个数: getNodeNumRec（递归），getNodeNum（迭代） </div><div class="line"></div><div class="line">递归解法：Time O(n)      </div><div class="line">(1) 如果二叉树为空，节点个数为0       </div><div class="line">(2) 如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1  </div><div class="line"></div><div class="line">迭代解法：Time O(n)     </div><div class="line">使用DFS 或者 BFS 遍历所有节点，统计节点个数</div></pre></td></tr></table></figure>
<p>public int getNodeNumRec(TreeNode root) {<br>    if(root == null) return 0;<br>    return getNodeNumRec(root.left)+getNodeNumRec(root.right)+1;<br>}</p>
<p>//Traverse tree use BFS<br>public int getNodeNum(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new ArrayDeque&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        count += size;<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>    return count;<br>}</treenode></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     </div><div class="line">2.求二叉树的深度: getDepthRec（递归），getDepth(迭代)</div><div class="line">LeetCode - 104.Maximum Depth of Binary Tree</div><div class="line">递归解法:  Time O(n)       </div><div class="line">(1) 如果二叉树为空，深度为0</div><div class="line">(2) 如果二叉树不为空，二叉树深度 = max(左子树深度，右子树的深度) + 1</div><div class="line"></div><div class="line">迭代解法： Time O(n)    </div><div class="line">(1)解法一：使用BFS,统计层数 即 执行循环的次数</div><div class="line">(2)解法二：使用DFS,每次一条路径到底，比较深度，把所有树遍历一遍，找出最大长度</div></pre></td></tr></table></figure>
<p>public int getDepthRec(TreeNode root) {<br>    if(root==null) retrun 0;<br>    return Math.max(getDepthRec(root.left),getDepthRec(root.right))+1;<br>}</p>
<p>//Traverse tree use BFS<br>public int getNodeNum(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        count++;<br>        for(int i=0;i<size;i++) {="" treenode="" node="queue.poll();" if(node.left!="null)" queue.add(node.left);="" if(node.right!="null)" queue.add(node.right);="" }="" return="" count;="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3.前序遍历，中序遍历，后序遍历: preorderTraversalRec, preorderTraversal, inorderTraversalRec, postorderTraversalRec (&lt;https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_2&gt;) </div><div class="line">       </div><div class="line">LeetCode - 104.Binary Tree Preorder Traversal     </div><div class="line">Pre-Order递归解法:  Time O(n)       </div><div class="line">(1) 如果二叉树为空，返回      </div><div class="line">(2) 如果二叉树不为空，访问根节点,list.add(root.val), 前序遍历左子树，前序遍历右子树</div></pre></td></tr></table></size;i++)></treenode></p>
<p>//Solution1: add helper() method<br>public List<integer> preorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list,root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node==null) return;<br>    list.add(node.val);<br>    helper(list,node.left);<br>    helper(list,node.right);<br>}</integer></p>
<p>//Solution2<br>public List<integer> preorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    list.add(root.val);<br>    list.addAll(preorderTraversalRec(root.left));<br>    list.addAll(preorderTraversalRec(root.right));<br>    return list;<br>}</integer></integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pre-Order迭代解法:  Time O(n), Space O(n)       </div><div class="line">使用Stack, 用List存储输出的节点，每次从右向左遍历子节点, 存入Stack中</div></pre></td></tr></table></figure>
<p>public List<integer> preorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        list.add(node.val);<br>        if(node.right!=null)stack.push(node.right);<br>        if(node.left!=null)stack.push(node.left);<br>    }<br>    return list;<br>}</treenode></integer></integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">LeetCode - 94.Binary Tree Inorder Traversal   </div><div class="line">In-Order递归解法:  Time O(n)       </div><div class="line">(1) 如果二叉树为空，返回       </div><div class="line">(2) 如果二叉树不为空，中序遍历左子树，访问根节点,list.add(root.val), 中序遍历右子树</div></pre></td></tr></table></figure>
<p>public List<integer> inorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list, root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node == null) return;<br>    helper(list, node.left);<br>    list.add(node.val);<br>    helper(list,node.right);<br>}</integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">In-Order迭代解法:  Time O(n)       </div><div class="line">(1) 使用Stack, 先把每个需要存入的节点遍历所有左子节点，并全部存入      </div><div class="line">(2) 如果左子树为空，则从stack中输出一个节点，用list依次记录所有输出节点，以此节点向右访问一次右节点，然后重复（1）操作。</div><div class="line">(3) 特别注意：这里有个tricky的地方，就是一开始是从root节点直接向左遍历，但当我从stack中输出的节点就不需要再向左遍历，所以需要创建两个新的节点，一个代表从stack输出的节点，一个代表向右找到的新节点。只有向右找到的新节点需要左遍历。</div></pre></td></tr></table></figure>
<p>public List<integer> inorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode node = root;<br>    while(!stack.isEmpty()) {</treenode></integer></integer></p>
<pre><code>    while(node.left!=null) {
        stack.push(node.left);
        node = node.left;
    }
    TreeNode addNode = stack.pop();
    list.add(addNode.val);

    if(addNode.right!=null) {
        stack.push(addNode.right);
        node = addNode.right;
    }    
}
return list;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LeetCode - 145.Binary Tree Postorder Traversal   </div><div class="line">Post-Order递归解法:  Time O(n)       </div><div class="line">(1) 如果二叉树为空，返回       </div><div class="line">(2) 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点,list.add(root.val)</div></pre></td></tr></table></figure>
<p>public List<integer> postorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list, root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node == null) return;<br>    helper(list, node.left);<br>    helper(list, node.right);<br>    list.add(node.val);<br>}</integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Post-Order迭代解法:        </div><div class="line">解法一：      </div><div class="line">(1) 使用双栈法，使用先序遍历的反向逆转</div><div class="line">(2) 首先先序遍历是：`self, left, right`, 反向先序遍历为`self, right, left`, 在使用另一个stack逆转为`left, right, self` 即为后序遍历</div><div class="line"></div><div class="line">解法二：</div><div class="line">(1) 解法像pre-order,stack先压人root，然后压入右节点再压入左节点</div><div class="line">(2) 有两种情况需要从stack中压出节点并添加到list中，一是左右节点为null，二是左右的节点都被访问过。</div></pre></td></tr></table></figure>
<p>//Solution1: Two stack<br>public List<integer> postorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    Stack<treenode> reverseStack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        reverseStack.push(node);<br>        if(node.left!=null) stack.push(node.left);<br>        if(node.right!=null) stack.push(node.right);<br>    }<br>    while(!reverseStack.isEmpty()) {<br>        list.add(reverseStack.pop());<br>    }<br>    return list;<br>}</treenode></treenode></integer></integer></p>
<p>//Solution2:<br>public List<integer> postorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode prev = null;<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.peek();<br>        //node.left==null &amp;&amp; node.right==null表明node为叶节点<br>        //prev!=null &amp;&amp; prev==node.left 表明左子树遍历完，右子树为空<br>        //prev!=null &amp;&amp; prev==node.right 表明右子树遍历完<br>        //prev!=node.left&amp;&amp;prev!=node.right表明stack已经连续输出节点到另一分支<br>        if((node.left==null &amp;&amp; node.right==null)||(prev!=null &amp;&amp; (prev == node.left || prev==node.right))) {<br>            node = stack.pop();<br>            list.add(node.val);<br>            prev = node;<br>        }else {<br>            if(node.right!=null) stack.push(node.right);<br>            if(node.left!=null) stack.push(node.left);<br>        }<br>    }<br>    return list;<br>}</treenode></integer></integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4.分层遍历二叉树（按层次从上往下，从左往右）: levelTraversal, levelTraversalRec（递归解法）</div><div class="line"></div><div class="line">LeetCode - 102.Binary Tree Level Order Traversal </div><div class="line"></div><div class="line">递归解法：</div><div class="line">记录每层个数，用层数去比较大lists的size，如果size等于层数，则需要添加一个新的list用于记录当前层的nodes，如果size小于层数，则拿出lists中相对应层数的list去添加nodes.</div></pre></td></tr></table></figure>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();
    helper(lists, root,0);
    return lists;
}
void helper(List&lt;List&lt;Integer&gt;&gt; lists, TreeNode node, int level) {
    if(node == null) return;
    //add a new list to the new level of nodes
    if(lists.size() == level) lists.add(new ArrayList&lt;Integer&gt;());
    List&lt;Integer&gt; temp = lists.get(level);
    temp.add(node.val);
    helper(lists, node.left,level+1);
    helper(lists, node.right,level+1);

}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法：    </div><div class="line">使用Queue实现BFS</div></pre></td></tr></table></figure>
<p>//Traverse tree use BFS<br>public void levelTraversal(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>}</treenode></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">5.将二叉查找树变为有序的双向链表: convertBST2DLLRec, convertBST2DLL</div><div class="line"></div><div class="line">LeetCode - 114.Flatten Binary Tree to Linked List </div><div class="line"></div><div class="line">递归解法：</div><div class="line">(1) 如果二叉树为空，返回       </div><div class="line">(2) 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点, 把根节点的左子树移到右边，左边致为null,把根节点的原右子树放到原左子树的最右边</div></pre></td></tr></table></figure>
<pre><code>public void flatten(TreeNode root) {
    if(root == null) return;

    flatten(root.left);
    flatten(root.right);

    TreeNode right = root.right;
    root.right = root.left;
    root.left = null;
    TreeNode cur = root;
    while(cur.right!=null) cur = cur.right;
    cur.right = right;

}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line">1. 依次遍历右节点</div><div class="line">2. 每次把current node 的右子树放到左子树的最右边，然后把左子树放到右边之后，把左边致为null</div></pre></td></tr></table></figure>
<p>public void flatten(TreeNode root) {<br>        if(root == null) return;<br>        while(root!=null) {<br>            if(root.left==null){<br>                root = root.right;<br>                continue;<br>            }<br>            TreeNode left = root.left;<br>            while(left.right!=null) {<br>                left = left.right;<br>            }<br>            left.right = root.right;<br>            root.right = root.left;<br>            root.left = null;<br>        }</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">6. 求二叉树第K层的节点个数：getNodeNumKthLevelRec, getNodeNumKthLevel</div><div class="line">7. 求二叉树中叶子节点的个数：getNodeNumLeafRec, getNodeNumLeaf </div><div class="line">8. 判断两棵二叉树是否相同的树：isSameRec, isSame</div><div class="line">9. 判断二叉树是不是平衡二叉树：isAVLRec </div><div class="line">10. 求二叉树的镜像（破坏和不破坏原来的树两种情况）：</div><div class="line">     mirrorRec, mirrorCopyRec         </div><div class="line">     mirror, mirrorCopy        </div><div class="line">10.1 判断两个树是否互相镜像：isMirrorRec isMirror</div><div class="line">11. 求二叉树中两个节点的最低公共祖先节点：     </div><div class="line">       LAC        求解最小公共祖先, 使用list来存储path.      </div><div class="line">       LCABstRec  递归求解BST树.      </div><div class="line">       LCARec     递归算法 .       </div><div class="line">12. 求二叉树中节点的最大距离：getMaxDistanceRec </div><div class="line">13. 由前序遍历序列和中序遍历序列重建二叉树：rebuildBinaryTreeRec</div><div class="line">14. 判断二叉树是不是完全二叉树：isCompleteBinaryTree, isCompleteBinaryTreeRec</div><div class="line">15. 找出二叉树中最长连续子串(即全部往左的连续节点，或是全部往右的连续节点）findLongest</div><div class="line">    </div><div class="line"></div><div class="line">#### 学习后总结：</div><div class="line">##### When to use Pre-Order, In-Order, Post-Order</div><div class="line"></div><div class="line">- Pre-Order: Recursively, this is `self, left, right`. From root node to right most node. Firstly, if you know you need to explore the roots before inspecting any leaves, you should pick pre-order because you will encounter all the roots before all of the leaves.  Secondly, if you want to simply print out the hierachical format of the tree in a linear format, use preorder traversal.</div></pre></td></tr></table></figure></p>
<ul>
<li>Root<ul>
<li>A<ul>
<li>B</li>
<li>C</li>
</ul>
</li>
<li>D<ul>
<li>E</li>
<li>F<br>  -G    </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- Post-Order: Recursively, this is`left, right, self`. From left most node to right most node.  If you know you need to explore all the leaves before any nodes, you should pick post-order because you don&apos;t waster any time inspecting roots in search for leaves. 或者应用在：树的删除。为了释放树结构的内存，某节点在被释放以前，其左右子树的节点首先应当被释放掉。</div><div class="line">- In-Order: Recursively, this is`left, self, right`. From left most node to right most node. If you know that the tree has an inherent sequence, and you want to flatten the tree back into the original sequence(simply process the items in the defined order).</div></pre></td></tr></table></figure>
<p>For example, you have a BST of a list of word or names, inorder traversal would print them out in order.</p>
<pre><code>+
</code></pre><p>  /      \<br> A     *<br>      /  \<br>     B    C</p>
<p>Output: A + B * C</p>
<p>If you want to evaluate the expression, you traverse the tree in postorder, applying each operator to the values from each of its sub-trees.      </p>
<p>```</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/" data-id="cis96xyi90015yejhsrhoptwi" class="article-share-link">Share</a><div class="tags"><a href="/tags/Seeking-Job/">Seeking Job</a></div><div class="post-nav"><a href="/2016/08/22/Day10-Algorithm-about-Itetation-and-Recursion/" class="pre">Day10 Algorithm about Itetation and Recursion</a><a href="/2016/08/19/Two-Sum-III-Data-structure-design/" class="next">Two Sum III - Data structure design</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm-Binary-Search-Tree/">Algorithm, Binary Search Tree</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm-Sorting/">Algorithm, Sorting</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-Collection/">Data Structure, Collection</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-HashMap-TreeMap-Hashtable-ConcuttentHashMap/">Data Structure, HashMap, TreeMap, Hashtable, ConcuttentHashMap</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-HashSet-TreeSet/">Data Structure, HashSet, TreeSet</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-List/">Data Structure, List</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Geek/">Geek</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Stack-Heap/">Stack, Heap</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/class-design-interface/">class design, interface</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/comparator-comparable/">comparator, comparable</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Seeking-Job/" style="font-size: 15px;">Seeking Job</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Flatten-Binary-Tree-to-Linked-List/">Flatten Binary Tree to Linked List</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Binary-Tree-Level-Order-Traversal/">Binary Tree Level Order Traversal</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Binary-Tree-Postorder-Traversal/">Binary Tree Postorder Traversal</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Binary-Tree-Inorder-Traversal/">Binary Tree Inorder Traversal</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Binary-Tree-Preorder-Traversal/">Binary Tree Preorder Traversal</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Maximum-Depth-of-Binary-Tree/">Maximum Depth of Binary Tree</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/22/Day10-Algorithm-about-Itetation-and-Recursion/">Day10 Algorithm about Itetation and Recursion</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/">Day9 Algorithm about Binary Search Tree</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/19/Two-Sum-III-Data-structure-design/">Two Sum III - Data structure design</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/18/Two-Sum-II-Input-array-is-sorted/">Two Sum II - Input array is sorted</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Xinli's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>