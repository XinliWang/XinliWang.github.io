<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Day9 Algorithm about Binary Tree | Xinli's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Day9 Algorithm about Binary Tree</h1><a id="logo" href="/.">Xinli's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Day9 Algorithm about Binary Tree</h1><div class="post-meta">Aug 22, 2016<span> | </span><span class="category"><a href="/categories/Algorithm-Binary-Tree/">Algorithm, Binary Tree</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>本篇是关于二叉树Binary Tree算法的分析和总结。</p>
<h2 id="攻略模板："><a href="#攻略模板：" class="headerlink" title="攻略模板："></a>攻略模板：</h2><ul>
<li>回忆算法特性</li>
<li>实现算法功能</li>
<li>实战训练使用该算法</li>
<li>总结该算法特点，并总结算法题</li>
</ul>
<h4 id="自己回忆："><a href="#自己回忆：" class="headerlink" title="自己回忆："></a>自己回忆：</h4><ul>
<li>一般二叉树的查找可以使用DFS 和 BFS</li>
<li>平衡二叉树可以使用二分法，时间复杂度为O(logn)</li>
<li>二叉树的遍历有先序遍历，中序遍历 和 后序遍历</li>
<li>Binary Tree and Binary Search Tree: Each node of BT and BST only allowed two children nodes. What’s more, in BST, left &lt; current &lt; right.</li>
</ul>
<h4 id="实现算法："><a href="#实现算法：" class="headerlink" title="实现算法："></a>实现算法：</h4><p>在这里我们总结出经典15道二叉树题目： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//Definition for a binary tree node.</div><div class="line">Class TreeNode&#123;</div><div class="line">	int val;</div><div class="line">	TreeNode left;</div><div class="line">	TreeNode right;</div><div class="line">	TreeNode(int x) &#123;</div><div class="line">		val = x;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">```          </div><div class="line"></div><div class="line">1.求二叉树中的节点个数: getNodeNumRec（递归），getNodeNum（迭代） </div><div class="line"></div><div class="line">递归解法：Time O(n)      </div><div class="line">(1) 如果二叉树为空，节点个数为0       </div><div class="line">(2) 如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1  </div><div class="line"></div><div class="line">迭代解法：Time O(n)     </div><div class="line">使用DFS 或者 BFS 遍历所有节点，统计节点个数</div></pre></td></tr></table></figure>
<p>public int getNodeNumRec(TreeNode root) {<br>    if(root == null) return 0;<br>    return getNodeNumRec(root.left)+getNodeNumRec(root.right)+1;<br>}</p>
<p>//Traverse tree use BFS<br>public int getNodeNum(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new ArrayDeque&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        count += size;<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>    return count;<br>}</treenode></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     </div><div class="line">2.求二叉树的深度: getDepthRec（递归），getDepth(迭代)</div><div class="line">LeetCode - 104.Maximum Depth of Binary Tree</div><div class="line">递归解法:  Time O(n)       </div><div class="line">(1) 如果二叉树为空，深度为0</div><div class="line">(2) 如果二叉树不为空，二叉树深度 = max(左子树深度，右子树的深度) + 1</div><div class="line"></div><div class="line">迭代解法： Time O(n)    </div><div class="line">(1)解法一：使用BFS,统计层数 即 执行循环的次数</div><div class="line">(2)解法二：使用DFS,每次一条路径到底，比较深度，把所有树遍历一遍，找出最大长度</div></pre></td></tr></table></figure>
<p>public int getDepthRec(TreeNode root) {<br>    if(root==null) retrun 0;<br>    return Math.max(getDepthRec(root.left),getDepthRec(root.right))+1;<br>}</p>
<p>//Traverse tree use BFS<br>public int getNodeNum(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        count++;<br>        for(int i=0;i<size;i++) {="" treenode="" node="queue.poll();" if(node.left!="null)" queue.add(node.left);="" if(node.right!="null)" queue.add(node.right);="" }="" return="" count;="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3.前序遍历，中序遍历，后序遍历: preorderTraversalRec, preorderTraversal, inorderTraversalRec, postorderTraversalRec (&lt;https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_2&gt;) </div><div class="line">       </div><div class="line">LeetCode - 104.Binary Tree Preorder Traversal     </div><div class="line">Pre-Order递归解法:  Time O(n)       </div><div class="line">(1) 如果二叉树为空，返回      </div><div class="line">(2) 如果二叉树不为空，访问根节点,list.add(root.val), 前序遍历左子树，前序遍历右子树</div></pre></td></tr></table></size;i++)></treenode></p>
<p>//Solution1: add helper() method<br>public List<integer> preorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list,root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node==null) return;<br>    list.add(node.val);<br>    helper(list,node.left);<br>    helper(list,node.right);<br>}</integer></p>
<p>//Solution2<br>public List<integer> preorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    list.add(root.val);<br>    list.addAll(preorderTraversalRec(root.left));<br>    list.addAll(preorderTraversalRec(root.right));<br>    return list;<br>}</integer></integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pre-Order迭代解法:  Time O(n), Space O(n)       </div><div class="line">使用Stack, 用List存储输出的节点，每次从右向左遍历子节点, 存入Stack中</div></pre></td></tr></table></figure>
<p>public List<integer> preorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        list.add(node.val);<br>        if(node.right!=null)stack.push(node.right);<br>        if(node.left!=null)stack.push(node.left);<br>    }<br>    return list;<br>}</treenode></integer></integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">LeetCode - 94.Binary Tree Inorder Traversal   </div><div class="line">In-Order递归解法:  Time O(n)       </div><div class="line">(1) 如果二叉树为空，返回       </div><div class="line">(2) 如果二叉树不为空，中序遍历左子树，访问根节点,list.add(root.val), 中序遍历右子树</div></pre></td></tr></table></figure>
<p>public List<integer> inorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list, root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node == null) return;<br>    helper(list, node.left);<br>    list.add(node.val);<br>    helper(list,node.right);<br>}</integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">In-Order迭代解法:  Time O(n)       </div><div class="line">(1) 使用Stack, 先把每个需要存入的节点遍历所有左子节点，并全部存入      </div><div class="line">(2) 如果左子树为空，则从stack中输出一个节点，用list依次记录所有输出节点，以此节点向右访问一次右节点，然后重复（1）操作。</div><div class="line">(3) 特别注意：这里有个tricky的地方，就是一开始是从root节点直接向左遍历，但当我从stack中输出的节点就不需要再向左遍历，所以需要创建两个新的节点，一个代表从stack输出的节点，一个代表向右找到的新节点。只有向右找到的新节点需要左遍历。</div></pre></td></tr></table></figure>
<p>public List<integer> inorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode node = root;<br>    while(!stack.isEmpty()) {</treenode></integer></integer></p>
<pre><code>    while(node.left!=null) {
        stack.push(node.left);
        node = node.left;
    }
    TreeNode addNode = stack.pop();
    list.add(addNode.val);

    if(addNode.right!=null) {
        stack.push(addNode.right);
        node = addNode.right;
    }    
}
return list;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LeetCode - 145.Binary Tree Postorder Traversal   </div><div class="line">Post-Order递归解法:  Time O(n)       </div><div class="line">(1) 如果二叉树为空，返回       </div><div class="line">(2) 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点,list.add(root.val)</div></pre></td></tr></table></figure>
<p>public List<integer> postorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list, root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node == null) return;<br>    helper(list, node.left);<br>    helper(list, node.right);<br>    list.add(node.val);<br>}</integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Post-Order迭代解法:        </div><div class="line">解法一：      </div><div class="line">(1) 使用双栈法，使用先序遍历的反向逆转</div><div class="line">(2) 首先先序遍历是：`self, left, right`, 反向先序遍历为`self, right, left`, 在使用另一个stack逆转为`left, right, self` 即为后序遍历</div><div class="line"></div><div class="line">解法二：</div><div class="line">(1) 解法像pre-order,stack先压人root，然后压入右节点再压入左节点</div><div class="line">(2) 有两种情况需要从stack中压出节点并添加到list中，一是左右节点为null，二是左右的节点都被访问过。</div></pre></td></tr></table></figure>
<p>//Solution1: Two stack<br>public List<integer> postorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    Stack<treenode> reverseStack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        reverseStack.push(node);<br>        if(node.left!=null) stack.push(node.left);<br>        if(node.right!=null) stack.push(node.right);<br>    }<br>    while(!reverseStack.isEmpty()) {<br>        list.add(reverseStack.pop());<br>    }<br>    return list;<br>}</treenode></treenode></integer></integer></p>
<p>//Solution2:<br>public List<integer> postorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode prev = null;<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.peek();<br>        //node.left==null &amp;&amp; node.right==null表明node为叶节点<br>        //prev!=null &amp;&amp; prev==node.left 表明左子树遍历完，右子树为空<br>        //prev!=null &amp;&amp; prev==node.right 表明右子树遍历完<br>        //prev!=node.left&amp;&amp;prev!=node.right表明stack已经连续输出节点到另一分支<br>        if((node.left==null &amp;&amp; node.right==null)||(prev!=null &amp;&amp; (prev == node.left || prev==node.right))) {<br>            node = stack.pop();<br>            list.add(node.val);<br>            prev = node;<br>        }else {<br>            if(node.right!=null) stack.push(node.right);<br>            if(node.left!=null) stack.push(node.left);<br>        }<br>    }<br>    return list;<br>}</treenode></integer></integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4.分层遍历二叉树（按层次从上往下，从左往右）: levelTraversal, levelTraversalRec（递归解法）</div><div class="line"></div><div class="line">LeetCode - 102.Binary Tree Level Order Traversal </div><div class="line"></div><div class="line">递归解法：     </div><div class="line">记录每层个数，用层数去比较大lists的size，如果size等于层数，则需要添加一个新的list用于记录当前层的nodes，如果size小于层数，则拿出lists中相对应层数的list去添加nodes.</div></pre></td></tr></table></figure>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();
    helper(lists, root,0);
    return lists;
}
void helper(List&lt;List&lt;Integer&gt;&gt; lists, TreeNode node, int level) {
    if(node == null) return;
    //add a new list to the new level of nodes
    if(lists.size() == level) lists.add(new ArrayList&lt;Integer&gt;());
    List&lt;Integer&gt; temp = lists.get(level);
    temp.add(node.val);
    helper(lists, node.left,level+1);
    helper(lists, node.right,level+1);

}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法：    </div><div class="line">使用Queue实现BFS</div></pre></td></tr></table></figure>
<p>//Traverse tree use BFS<br>public void levelTraversal(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>}</treenode></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">5.将二叉查找树变为有序的双向链表: convertBST2DLLRec, convertBST2DLL</div><div class="line"></div><div class="line">LeetCode - 114.Flatten Binary Tree to Linked List </div><div class="line"></div><div class="line">递归解法：     </div><div class="line">(1) 如果二叉树为空，返回           </div><div class="line">(2) 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点, 把根节点的左子树移到右边，左边致为null,把根节点的原右子树放到原左子树的最右边</div></pre></td></tr></table></figure>
<pre><code>public void flatten(TreeNode root) {
    if(root == null) return;

    flatten(root.left);
    flatten(root.right);

    TreeNode right = root.right;
    root.right = root.left;
    root.left = null;
    TreeNode cur = root;
    while(cur.right!=null) cur = cur.right;
    cur.right = right;

}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line">1. 依次遍历右节点</div><div class="line">2. 每次把current node 的右子树放到左子树的最右边，然后把左子树放到右边之后，把左边致为null</div></pre></td></tr></table></figure>
<p>public void flatten(TreeNode root) {<br>        if(root == null) return;<br>        while(root!=null) {<br>            if(root.left==null){<br>                root = root.right;<br>                continue;<br>            }<br>            TreeNode left = root.left;<br>            while(left.right!=null) {<br>                left = left.right;<br>            }<br>            left.right = root.right;<br>            root.right = root.left;<br>            root.left = null;<br>        }</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">6.求二叉树第K层的节点个数：getNodeNumKthLevelRec, getNodeNumKthLevel</div><div class="line">递归解法：即把问题分解的过程    </div><div class="line">(1) 如果current node为null 或者 k为0，返回0.</div><div class="line">(2) 如果二叉树不为空且k为1，则返回1.</div><div class="line">(3) 如果二叉树不为空且k&gt;1, 则返回 左子树+右子树 的个数.</div></pre></td></tr></table></figure></p>
<p>public int getNodeNumKthLevel(TreeNode root, int k) {<br>    if(root == null || k==0) return 0;<br>    if(k==1) return 1;<br>    return  getNodeNumKthLevel(root.left,k-1) + getNodeNumKthLevel(root.right,k-1);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line">1. 使用BFS, 用Queue去存储每一层节点</div><div class="line">2. 返回某层节点数，即size of Queue</div></pre></td></tr></table></figure>
<p>//Traverse tree use BFS<br>public int getNodeNumKthLevel(TreeNode root, int k) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    int result = 0;<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        if(–k == 0){<br>            result = size;<br>            break;<br>        }<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>    return result;<br>}</treenode></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">7.求二叉树中叶子节点的个数：getNodeNumLeafRec, getNodeNumLeaf </div><div class="line">递归解法：即把问题分解的过程    </div><div class="line">(1) 如果二叉树为null，返回0</div><div class="line">(2) 如果二叉树不为空且其左右子树均为null，则返回1. 叶子数 = 左子树叶子数 + 右子树叶子数</div></pre></td></tr></table></figure>
<p>public int getNodeNumLeafRec(TreeNode root) {<br>    if(root == null) return 0;<br>    if(root.right==null &amp;&amp; root.left==null) return 1;<br>    return  getNodeNumLeafRec(root.left) + getNodeNumLeafRec(root.right);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line">1. 使用BFS, 用Queue去存储每一层节点</div><div class="line">2. 判断每个node是否含有左子树和右子树，如果没有则 叶子数+1</div></pre></td></tr></table></figure>
<p>//Traverse tree use BFS<br>public int getNodeNumKthLevel(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left==null &amp;&amp; node.right==null)count++;<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>    return count;<br>}</treenode></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">8.判断两棵二叉树是否相同的树：isSameRec, isSame</div><div class="line"></div><div class="line">LeetCode - 100.Same Tree     </div><div class="line"></div><div class="line">递归解法：    </div><div class="line">(1) 如果两个树都为空，返回true. 如果其中有一个节点为空或者两个节点的值不等，返回false. </div><div class="line">(2) 递归遍历左子树和右子树，重复（1）</div></pre></td></tr></table></figure>
<pre><code>public boolean isSameTree(TreeNode p, TreeNode q) {
    if(p==null &amp;&amp; q==null) return true;
    if(p==null || q==null) return false;
    if(p.val!=q.val) return false;
    if(p.val==q.val) return isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line">1. 对两个树同时使用先序遍历</div><div class="line">2. 每次比较两个点</div></pre></td></tr></table></figure>
<p>public boolean isSameTree(TreeNode p, TreeNode q) {        if(p==null &amp;&amp; q==null) return true;<br>        if(p==null || q==null) return false;<br>        Stack<treenode> s1 = new Stack&lt;&gt;();<br>        Stack<treenode> s2 = new Stack&lt;&gt;();<br>        s1.push(p);<br>        s2.push(q);<br>        while(!s1.isEmpty() &amp;&amp; !s2.isEmpty()) {<br>            TreeNode node1 = s1.pop();<br>            TreeNode node2 = s2.pop();<br>            if(node1==null &amp;&amp; node2==null) continue;<br>            if(node1!=null &amp;&amp; node2!=null &amp;&amp; node1.val==node2.val) {<br>                s1.push(node1.left);<br>                s1.push(node1.right);<br>                s2.push(node2.left);<br>                s2.push(node2.right);<br>            } else {<br>                return false;<br>            }<br>        }<br>        return true;<br>    }</treenode></treenode></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">9.判断二叉树是不是平衡二叉树：isBalanced </div><div class="line"></div><div class="line">LeetCode - 110.Balanced Binary Tree</div><div class="line"></div><div class="line">递归解法1：O(NlogN)    </div><div class="line">遍历每个点，每次都比较其左子树和右子树的高度</div></pre></td></tr></table></figure>
<pre><code>public boolean isBalanced(TreeNode root) {
    if(root==null) return true;
    if(Math.abs(getDepth(root.left)-getDepth(root.right))&gt;1) return false;
    return isBalanced(root.left) &amp;&amp; isBalanced(root.right);
}

int getDepth(TreeNode node) {
    if(node==null) return 0;
    return Math.max(getDepth(node.left),getDepth(node.right))+1;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">递归解法2： </div><div class="line">   </div><div class="line">1. 自下而上，每次比较左子树和右子树，如果两边高度大于1，则返回-1。如果不是，则返回高度，供父节点使用。</div><div class="line">2. 如果有一边是-1，就直接向上，不用再求高度。</div></pre></td></tr></table></figure>
<p>public boolean isBalanced(TreeNode root) {            if(getDepth(root)==-1) return false;<br>        return true;<br>    }</p>
<pre><code>int getDepth(TreeNode node) {
    if(node==null) return 0;

    int leftDepth = getDepth(node.left);
    if(leftDepth==-1) return -1;

    int rightDepth = getDepth(node.right);
    if(rightDepth==-1) return -1;

    int diff = Math.abs(leftDepth-rightDepth);
    if(diff&gt;1) {
        return -1;
    } else {
        return Math.max(leftDepth,rightDepth) + 1;
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">10.求二叉树的镜像（破坏和不破坏原来的树两种情况）：</div><div class="line">     mirrorRec, mirrorCopyRec         </div><div class="line">     mirror, mirrorCopy   </div><div class="line"></div><div class="line">破坏原来的树     </div><div class="line">递归解法：   </div><div class="line">(1) 如果二叉树为空，返回null.</div><div class="line">(2) 如果二叉树不为空, 无论有没有左右子树，交换他们的位置. 即自底向上依次调换所有左右子树位置。</div></pre></td></tr></table></figure>
<pre><code>public TreeNode mirrorRec(TreeNode root) {
    if(root==null) return null;
    TreeNode left = mirrorRec(root.left);
    TreeNode right = mirrorRec(root.right);
    root.right = left;
    root.left = right;
    return root;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">使用BFS,每次遍历一个点都交换它左右子树的位置</div></pre></td></tr></table></figure>
<p>public TreeNode mirror(TreeNode root) {<br>    if(root == null) return null;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        TreeNode node = queue.poll();<br>        if(node.left==null &amp;&amp; node.right==null) continue;<br>        TreeNode left = node.left;<br>        node.left = node.right;<br>        node.right = left;<br>        if(node.left!=null) queue.add(node.left);<br>        if(node.right!=null) queue.add(node.right);</treenode></p>
<pre><code>}
return root;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">不破坏原来的树     </div><div class="line">递归解法：   </div><div class="line">(1) 如果二叉树为空，返回null.</div><div class="line">(2) 如果二叉树不为空, 使用先序遍历，首先创建新的节点，然后左右颠倒构造新的二叉树</div></pre></td></tr></table></figure>
<pre><code>public TreeNode mirrorCopyRec(TreeNode root) {
    if(root==null) return null;    
    TreeNode newRoot = new TreeNode(root.val);
    newRoot.left = mirrorRec(root.right);
    newRoot.right = mirrorRec(root.left);
    return newRoot;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">使用Pre-Order, 保持两个stack，使新创建的点与原来的树保持一一对应.</div></pre></td></tr></table></figure>
<p>public TreeNode mirror(TreeNode root) {<br>    if(root == null) return null;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    Stack<treenode> newStack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode newRoot = new TreeNode(root.val);<br>    newStack.push(newRoot);<br>    while(!queue.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        TreeNode newNode = newStack.pop();<br>        if(node.left!=null) {<br>            stack.push(node.left);<br>            newNode.rihgt = newTreeNode(node.left.val);<br>            stack.push(newNode.right);<br>        }<br>        if(node.right!=null) {<br>            stack.push(node.right);<br>            newNode.left = newTreeNode(node.right.val);<br>            stack.push(newNode.left);<br>        }<br>    }<br>    return newRoot;<br>}</treenode></treenode></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">10.1 判断两个树是否互相镜像：isMirrorRec isMirror</div><div class="line"></div><div class="line">递归解法：   </div><div class="line">(1) 如果两个二叉树都为空，返回true.</div><div class="line">(2) 如果只有其中一个二叉树为空，返回false.</div><div class="line">(3) 若果两个节点的val不相等，返回false.</div><div class="line">(4) 比较一个树的左子树和另个树的右子树，以及一个树的右子树和另个树的左子树.</div></pre></td></tr></table></figure>
<pre><code>public boolean isMirrorRec(TreeNode p, TreeNode q) {
    if(p==null &amp;&amp; q==null) return true; 
    if(p==null || q==null) return false;
    if(p.val != q.val) return false;
    return isMirrorRec(p.left,q.right) &amp;&amp; isMirrorRec(p.right,q.left);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">使用Pre-Order,每次遍历交叉树的值</div></pre></td></tr></table></figure>
<p>public boolean isMirror(TreeNode p, TreeNode q) {<br>    if(p == null &amp;&amp; q==null) return true;<br>    if(p == null || q==null) return false;<br>    Stack<treenode> stack1 = new Stack&lt;&gt;();<br>    Stack<treenode> stack2 = new Stack&lt;&gt;();<br>    stack1.push(p);<br>    stack2.push(q);<br>    while(!p.isEmpty()&amp;&amp;!q.isEmpty()) {<br>        TreeNode node1 = stack1.pop();<br>        TreeNode node2 = stack2.pop();<br>        if(node1.val != node.val) return false;<br>        if((node1.left==null&amp;&amp;node2.rihgt!=null)||(node1.left!=null&amp;&amp;node2.rihgt==null)) return false;<br>        if(node1.left!=null &amp;&amp; node2.right!=null) {<br>            stack1.push(node1.left);<br>            stack2.push(node2.right);<br>        }<br>        if((node1.rihgt==null&amp;&amp;node2.left!=null)||(node1.right!=null&amp;&amp;node2.left==null)) return false;<br>        if(node1.rihgt!=null &amp;&amp; node2.left!=null) {<br>            stack1.push(node1.right);<br>            stack2.push(node2.left);<br>        }<br>    }<br>    return true;<br>}</treenode></treenode></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">11.求二叉树中两个节点的最低公共祖先节点：     </div><div class="line">       getLastCommonParent    求解最小公共祖先, 使用list来存储path.     </div><div class="line">       getLastCommonParentRec     递归算法 .      </div><div class="line">       </div><div class="line">LeetCode - 236.Lowest Common Ancestor of a Binary Tree    </div><div class="line"></div><div class="line">递归解法：   </div><div class="line">(1) 如果从根节点出发，分别从左右两边找到两个节点，则LastCommonParrent是根节点</div><div class="line">(2) 如果从根节点的左子树出发，找到两节点，则LastCommonParrent在左子树</div><div class="line">(3) 如果从根节点的右子树出发，找到两节点，则LastCommonParrent在右子树</div></pre></td></tr></table></figure>
<pre><code>//Solution1:
public TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) {
    if(findNode(root.left,p)) {
        if(findNode(root.left,q)) {
            return getLastCommonParentRec(root.left,p,q);
        }else {
            return root;
        }
    }else {
        if(findNode(root.right,q)) {
            return getLastCommonParentRec(root.right,p,q);
        }else {
            return root;
        }
    }
}

boolean findNode(TreeNode root, TreeNode node) {
    if(root==null || node==null) return false;

    if(root==node) return true;

    boolean found = findNode(root.left,node);
    if(!found) {
        found = findNode(root.right,node);
    }
    return found;
}
</code></pre><p>//Solution2:<br>public TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) {<br>    if(root==null) return null;<br>    if(root==p || root==q) return root;<br>    TreeNode commonLeft = getLastCommonParentRec(root.left,p,q);<br>    TreeNode commonRight = getLastCommonParentRec(root.right,p,q);<br>    if(commonLeft!=null &amp;&amp; commonRight!=null) return root;<br>    if(commonLeft!=null) return commonLeft;<br>    return commonRight;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line"></div><div class="line">1. 分别从根节点出发，查找到达两个节点的路径，用list保存</div><div class="line">2. 然后同时比较两个list中的点，找出最后相同的两个点（两个list前面的点都相同）</div></pre></td></tr></table></figure>
<p>public TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) {<br>    ArrayList<treenode> list1 = new ArrayList&lt;&gt;();<br>    ArrayList<treenode> list2 = new ArrayList&lt;&gt;();<br>    boolean found1 = findPath(root,p,list1);<br>    boolean found2 = findPath(root,q,list2);<br>    if(!found1 || !found2) return null;</treenode></treenode></p>
<pre><code>TreeNode result = null;
for(int i=0;i&lt;Math.min(list1.size(),list2.size());i++) {
    if(list1.get(i)==list2.get(i)){
        result = list1.get(i);
    }else break;
}
return result;
</code></pre><p>}</p>
<p>boolean findPath(TreeNode root, TreeNode node, ArrayList<treenode> list) {<br>    if(root==null || node==null) return false;<br>    list.add(root);<br>    if(root == node) return true;<br>    boolean found = findPath(root.left,node,list);<br>    if(!found) {<br>        found = findPath(root.right,node,list);<br>    }<br>    if(!found) list.remove(root);<br>    return found;<br>}</treenode></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">       </div><div class="line">12.求二叉树中节点的最大距离：getMaxDistanceRec     </div><div class="line"></div><div class="line">递归法：      </div><div class="line">(1)求最大距离有两种情况：一是两个最大深度相加，它分别位于根节点的两侧；一是某个子节点下两个分支距离的和最大       </div><div class="line">(2)创建一个类去记录最大距离和最大深度，每次记录每个点的深度，以及最长距离</div></pre></td></tr></table></figure>
<p>public int getMaxDistanceRec(TreeNode root) {<br>    Distance dis = getDistance(root);<br>    return dis.maxDistance;<br>}</p>
<p>private Distance getDistance(TreeNode node) {<br>    //最底一层，深度为0<br>    if(node==null){<br>        Distance empty = new Distance(0,-1);<br>        return empty;<br>    }</p>
<pre><code>Distance left = getDistance(node.left);
Distance right = getDistance(node.right);

Distance dis = new Distance();
dis.maxDepth = Math.max(left.maxDepth,right.maxDepth)+1;
dis.maxDistance = Math.max(left.maxDepth+right.maxDepth+2,Math.max(left.maxDistance,right.maxDistance));
return dis;
</code></pre><p>}</p>
<p>class Distance {<br>    int maxDistance;<br>    int maxDepth;<br>    public Distance(){}<br>    public Distance(int maxDistance,int maxDepth){<br>        this.maxDistance = maxDistance;<br>        this.maxDepth = maxDepth;<br>    }<br> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">13.由前序遍历序列和中序遍历序列重建二叉树：rebuildBinaryTreeRec</div><div class="line"></div><div class="line">LeetCode - 105. Construct Binary Tree from Preorder and Inorder Traversal     </div><div class="line"></div><div class="line"></div><div class="line">递归解法：</div><div class="line"></div><div class="line">1. 由前序遍历可以知道第一个点是root，接下来几个点是左子树的点，之后几个是右子树的点, 特点是大体排列次序按照每个树的根节点顺序排列。</div><div class="line">2. 由中序遍历可以知道root点左边的都是左子树的点，右边都是右子树的点.可以得出左子树和右子树节点数</div></pre></td></tr></table></figure>
<p>public TreeNode rebuildBinaryTreeRec(int[]preorder,int[]inorder) {<br>    return buildTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1);<br>}</p>
<p>TreeNode buildTree(int[]preorder,int preStart, int preEnd, int[]inorder, int inStart, int inEnd) {<br>    if(preStart &gt; preEnd) return null;<br>    int rootVal = preorder[preStart];<br>    int inRoot=-1;<br>    for(int i=inStart,j=inEnd; i&lt;=j; i++,j–) {<br>        if(inorder[i] == rootVal) {<br>            inRoot = i;<br>            break;<br>        }else if(inorder[j] == rootVal){<br>            inRoot = j;<br>            break;<br>        }<br>    }<br>    TreeNode root = new TreeNode(rootVal);<br>    root.left = buildTree(preorder,preStart+1,preStart+(inRoot-inStart), inorder,inStart,inRoot-1);<br>    root.right = buildTree(preorder,preEnd-(inEnd-inRoot)+1,preEnd,inorder,inRoot+1,inEnd);<br>    return root;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">14.判断二叉树是不是完全二叉树：isCompleteBinaryTree, isCompleteBinaryTreeRec</div><div class="line"></div><div class="line">迭代解法： </div><div class="line">(1)使用BFS遍历节点，每层节点中，如果遇到左右子树为空时，或者遇到的第一个左子树不为空但右子树为空的情况，则后面所有的左右子树必须为空。即为完全二叉树。     </div><div class="line">(2)设立一个标志，如果有个节点的左右子树为空，则之后所有节点的子树必须为空。</div></pre></td></tr></table></figure>
<p>public boolean isCompleteBinaryTree(TreeNode root) {<br>    if(root == null) return false;<br>    Queue<treenode> queue = new Queue&lt;&gt;();<br>    queue.add(root);<br>    boolean flag = true;<br>    while(!queue.isEmpty()) {<br>        TreeNode node = queue.poll();<br>        if(flag) {<br>            if(node.left==null &amp;&amp; node.right==null) flag = false;<br>            else if(node.left==null &amp;&amp; node.right!=null) return false;<br>            else if(node.left!=null &amp;&amp; node.right==null) {<br>                flag = false;<br>                queue.add(node.left);<br>            }else {<br>                queue.add(node.left);<br>                queue.add(node.right);<br>            }</treenode></p>
<pre><code>    }else {
        if(node.left!=null || node.right!=null) return false;
    }
}
return true;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">15.找出二叉树中最长连续子串(即全部往左的连续节点，或是全部往右的连续节点）findLongest</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">#### 学习后总结：</div><div class="line">##### When to use Pre-Order, In-Order, Post-Order</div><div class="line"></div><div class="line">- Pre-Order: Recursively, this is `self, left, right`. From root node to right most node. Firstly, if you know you need to explore the roots before inspecting any leaves, you should pick pre-order because you will encounter all the roots before all of the leaves.  Secondly, if you want to simply print out the hierachical format of the tree in a linear format, use preorder traversal.</div></pre></td></tr></table></figure>
<ul>
<li>Root<ul>
<li>A<ul>
<li>B</li>
<li>C</li>
</ul>
</li>
<li>D<ul>
<li>E</li>
<li>F<br>  -G    </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- Post-Order: Recursively, this is`left, right, self`. From left most node to right most node.  If you know you need to explore all the leaves before any nodes, you should pick post-order because you don&apos;t waster any time inspecting roots in search for leaves. 或者应用在：树的删除。为了释放树结构的内存，某节点在被释放以前，其左右子树的节点首先应当被释放掉。</div><div class="line">- In-Order: Recursively, this is`left, self, right`. From left most node to right most node. If you know that the tree has an inherent sequence, and you want to flatten the tree back into the original sequence(simply process the items in the defined order).</div></pre></td></tr></table></figure>
<p>For example, you have a BST of a list of word or names, inorder traversal would print them out in order.</p>
<pre><code>+
</code></pre><p>  /      \<br> A     *<br>      /  \<br>     B    C</p>
<p>Output: A + B * C</p>
<p>If you want to evaluate the expression, you traverse the tree in postorder, applying each operator to the values from each of its sub-trees.      </p>
<p>```</p>
<h5 id="When-to-use-BFS-and-DFS-the-relationship-between-DFS-and-PreOrder"><a href="#When-to-use-BFS-and-DFS-the-relationship-between-DFS-and-PreOrder" class="headerlink" title="When to use BFS and DFS, the relationship between DFS and PreOrder"></a>When to use BFS and DFS, the relationship between DFS and PreOrder</h5></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/" data-id="cisc45nww00220gjh72f6j101" class="article-share-link">Share</a><div class="tags"><a href="/tags/Seeking-Job/">Seeking Job</a></div><div class="post-nav"><a href="/2016/08/22/Day10-Algorithm-about-Itetation-and-Recursion/" class="pre">Day10 Algorithm about Itetation and Recursion</a><a href="/2016/08/19/Two-Sum-III-Data-structure-design/" class="next">Two Sum III - Data structure design</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm-Binary-Tree/">Algorithm, Binary Tree</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm-Sorting/">Algorithm, Sorting</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-Collection/">Data Structure, Collection</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-HashMap-TreeMap-Hashtable-ConcuttentHashMap/">Data Structure, HashMap, TreeMap, Hashtable, ConcuttentHashMap</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-HashSet-TreeSet/">Data Structure, HashSet, TreeSet</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure-List/">Data Structure, List</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Geek/">Geek</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Stack-Heap/">Stack, Heap</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/class-design-interface/">class design, interface</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/comparator-comparable/">comparator, comparable</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Seeking-Job/" style="font-size: 15px;">Seeking Job</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/08/25/Lowest-Common-Ancestor-of-a-Binary-Tree/">Lowest Common Ancestor of a Binary Tree</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/25/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/">Construct Binary Tree from Preorder and Inorder Traversal</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/24/Balanced-Binary-Tree/">Balanced Binary Tree</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/24/Same-Tree/">Same Tree</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Flatten-Binary-Tree-to-Linked-List/">Flatten Binary Tree to Linked List</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Binary-Tree-Level-Order-Traversal/">Binary Tree Level Order Traversal</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Binary-Tree-Postorder-Traversal/">Binary Tree Postorder Traversal</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Binary-Tree-Inorder-Traversal/">Binary Tree Inorder Traversal</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Binary-Tree-Preorder-Traversal/">Binary Tree Preorder Traversal</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Maximum-Depth-of-Binary-Tree/">Maximum Depth of Binary Tree</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Xinli's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>