<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="google-site-verification" content="GY3xi-El9ePp4mSskpCuCNS4x4elE7wbFPe2eKCtS8Y"><title>Day9 Algorithm about Binary Tree | Xinli's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Day9 Algorithm about Binary Tree</h1><a id="logo" href="/.">Xinli's Blog</a><p class="description">Coding World</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Day9 Algorithm about Binary Tree</h1><div class="post-meta">Aug 22, 2016<span> | </span><span class="category"><a href="/categories/Algorithm/">Algorithm</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/" href="/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#攻略模板"><span class="toc-number">1.</span> <span class="toc-text">攻略模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自己回忆"><span class="toc-number">2.</span> <span class="toc-text">自己回忆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现算法"><span class="toc-number">3.</span> <span class="toc-text">实现算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-think-over-Divide-amp-Conquer"><span class="toc-number">3.1.</span> <span class="toc-text">How to think over Divide&Conquer</span></a></li></ol></li></ol></div></div><div class="post-content"><p>本篇是关于二叉树Binary Tree算法的分析和总结。</p>
<h2 id="攻略模板"><a href="#攻略模板" class="headerlink" title="攻略模板"></a>攻略模板</h2><ul>
<li>回忆算法特性</li>
<li>实现算法功能</li>
<li>实战训练使用该算法</li>
<li>总结该算法特点，并总结算法题</li>
</ul>
<h2 id="自己回忆"><a href="#自己回忆" class="headerlink" title="自己回忆"></a>自己回忆</h2><ul>
<li>一般二叉树的查找可以使用DFS 和 BFS</li>
<li>平衡二叉树可以使用二分法，时间复杂度为O(logn)</li>
<li>二叉树的遍历有先序遍历，中序遍历 和 后序遍历</li>
<li>Binary Tree and Binary Search Tree: Each node of BT and BST only allowed two children nodes. What’s more, in BST, left &lt; current &lt; right.</li>
</ul>
<h2 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h2><p>在这里我们总结出经典15道二叉树题目： </p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//Definition for a binary tree node.</div><div class="line">Class TreeNode&#123;</div><div class="line">	<span class="built_in">int</span> val;</div><div class="line">	TreeNode <span class="built_in">left</span>;</div><div class="line">	TreeNode <span class="built_in">right</span>;</div><div class="line">	TreeNode(<span class="built_in">int</span> x) &#123;</div><div class="line">		val = x;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">```          </div><div class="line"></div><div class="line"><span class="number">1</span>.求二叉树中的节点个数<span class="symbol">:</span> getNodeNumRec（递归），getNodeNum（迭代） </div><div class="line"></div><div class="line">递归解法：<span class="built_in">Time</span> O(<span class="built_in">n</span>)      </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，节点个数为<span class="number">0</span>       </div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + <span class="number">1</span>  </div><div class="line"></div><div class="line">迭代解法：<span class="built_in">Time</span> O(<span class="built_in">n</span>)     </div><div class="line">使用DFS 或者 BFS 遍历所有节点，统计节点个数</div></pre></td></tr></table></figure>
<p>public int getNodeNumRec(TreeNode root) {<br>    if(root == null) return 0;<br>    return getNodeNumRec(root.left)+getNodeNumRec(root.right)+1;<br>}</p>
<p>//Traverse tree use BFS<br>public int getNodeNum(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new ArrayDeque&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        count += size;<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>    return count;<br>}</treenode></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     </div><div class="line"><span class="number">2</span>.求二叉树的深度<span class="symbol">:</span> getDepthRec（递归），getDepth(迭代)</div><div class="line">LeetCode - <span class="number">104</span>.Maximum Depth of Binary Tree</div><div class="line">递归解法<span class="symbol">:</span>  <span class="built_in">Time</span> O(<span class="built_in">n</span>)       </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，深度为<span class="number">0</span></div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，二叉树深度 = <span class="built_in">max</span>(左子树深度，右子树的深度) + <span class="number">1</span></div><div class="line"></div><div class="line">迭代解法： <span class="built_in">Time</span> O(<span class="built_in">n</span>)    </div><div class="line">(<span class="number">1</span>)解法一：使用BFS,统计层数 即 执行循环的次数</div><div class="line">(<span class="number">2</span>)解法二：使用DFS,每次一条路径到底，比较深度，把所有树遍历一遍，找出最大长度</div></pre></td></tr></table></figure>
<p>public int getDepthRec(TreeNode root) {<br>    if(root==null) retrun 0;<br>    return Math.max(getDepthRec(root.left),getDepthRec(root.right))+1;<br>}</p>
<p>//Traverse tree use BFS<br>public int getNodeNum(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        count++;<br>        for(int i=0;i<size;i++) {="" treenode="" node="queue.poll();" if(node.left!="null)" queue.add(node.left);="" if(node.right!="null)" queue.add(node.right);="" }="" return="" count;="" <figure="" class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">3</span>.前序遍历，中序遍历，后序遍历: preorderTraversalRec, preorderTraversal, inorderTraversalRec, postorderTraversalRec (&lt;http<span class="variable">s:</span>//<span class="keyword">en</span>.wikipedia.org/wiki/Tree_traversal#Pre-order_2&gt;) </div><div class="line">       </div><div class="line">LeetCode - <span class="number">104</span>.Binary Tree Preorder Traversal     </div><div class="line">Pre-Order递归解法:  Time O(n)       </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回      </div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，访问根节点,<span class="keyword">list</span>.<span class="built_in">add</span>(root.val), 前序遍历左子树，前序遍历右子树</div></pre></td></tr></table></size;i++)></treenode></p>
<p>//Solution1: add helper() method<br>public List<integer> preorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list,root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node==null) return;<br>    list.add(node.val);<br>    helper(list,node.left);<br>    helper(list,node.right);<br>}</integer></p>
<p>//Solution2<br>public List<integer> preorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    list.add(root.val);<br>    list.addAll(preorderTraversalRec(root.left));<br>    list.addAll(preorderTraversalRec(root.right));<br>    return list;<br>}</integer></integer></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pre-<span class="keyword">Order</span>迭代解法:  Time <span class="keyword">O</span>(n), <span class="keyword">Space</span> <span class="keyword">O</span>(n)       </div><div class="line">使用<span class="keyword">Stack</span>, 用<span class="keyword">List</span>存储输出的节点，每次从右向左遍历子节点, 存入<span class="keyword">Stack</span>中</div></pre></td></tr></table></figure>
<p>public List<integer> preorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        list.add(node.val);<br>        if(node.right!=null)stack.push(node.right);<br>        if(node.left!=null)stack.push(node.left);<br>    }<br>    return list;<br>}</treenode></integer></integer></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">LeetCode - 94<span class="selector-class">.Binary</span> <span class="selector-tag">Tree</span> <span class="selector-tag">Inorder</span> <span class="selector-tag">Traversal</span>   </div><div class="line"><span class="selector-tag">In-Order</span>递归解法:  <span class="selector-tag">Time</span> <span class="selector-tag">O</span>(n)       </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回       </div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，中序遍历左子树，访问根节点,<span class="selector-tag">list</span><span class="selector-class">.add</span>(root.val), 中序遍历右子树</div></pre></td></tr></table></figure>
<p>public List<integer> inorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list, root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node == null) return;<br>    helper(list, node.left);<br>    list.add(node.val);<br>    helper(list,node.right);<br>}</integer></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">In</span>-<span class="keyword">Order</span>迭代解法:  Time O(<span class="keyword">n</span>)       </div><div class="line">(1) 使用<span class="keyword">Stack</span>, 先把每个需要存入的节点遍历所有左子节点，并全部存入      </div><div class="line">(2) 如果左子树为空，则从<span class="keyword">stack</span>中输出一个节点，用<span class="keyword">list</span>依次记录所有输出节点，以此节点向右访问一次右节点，然后重复（1）操作。</div><div class="line">(3) 特别注意：这里有个tricky的地方，就是一开始是从root节点直接向左遍历，但当我从<span class="keyword">stack</span>中输出的节点就不需要再向左遍历，所以需要创建两个新的节点，一个代表从<span class="keyword">stack</span>输出的节点，一个代表向右找到的新节点。只有向右找到的新节点需要左遍历。</div></pre></td></tr></table></figure>
<p>public List<integer> inorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode node = root;<br>    while(!stack.isEmpty()) {</treenode></integer></integer></p>
<pre><code>    while(node.left!=null) {
        stack.push(node.left);
        node = node.left;
    }
    TreeNode addNode = stack.pop();
    list.add(addNode.val);

    if(addNode.right!=null) {
        stack.push(addNode.right);
        node = addNode.right;
    }    
}
return list;
</code></pre><p>}</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LeetCode - 145<span class="selector-class">.Binary</span> <span class="selector-tag">Tree</span> <span class="selector-tag">Postorder</span> <span class="selector-tag">Traversal</span>   </div><div class="line"><span class="selector-tag">Post-Order</span>递归解法:  <span class="selector-tag">Time</span> <span class="selector-tag">O</span>(n)       </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回       </div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点,<span class="selector-tag">list</span><span class="selector-class">.add</span>(root.val)</div></pre></td></tr></table></figure>
<p>public List<integer> postorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list, root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node == null) return;<br>    helper(list, node.left);<br>    helper(list, node.right);<br>    list.add(node.val);<br>}</integer></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="type">Post</span>-<span class="type">Order</span>迭代解法:        </div><div class="line">解法一：      </div><div class="line">(<span class="number">1</span>) 使用双栈法，使用先序遍历的反向逆转</div><div class="line">(<span class="number">2</span>) 首先先序遍历是：`<span class="keyword">self</span>, <span class="keyword">left</span>, <span class="keyword">right</span>`, 反向先序遍历为`<span class="keyword">self</span>, <span class="keyword">right</span>, <span class="keyword">left</span>`, 在使用另一个stack逆转为`<span class="keyword">left</span>, <span class="keyword">right</span>, <span class="keyword">self</span>` 即为后序遍历</div><div class="line"></div><div class="line">解法二：</div><div class="line">(<span class="number">1</span>) 解法像pre-order,stack先压人root，然后压入右节点再压入左节点</div><div class="line">(<span class="number">2</span>) 有两种情况需要从stack中压出节点并添加到list中，一是左右节点为null，二是左右的节点都被访问过。</div></pre></td></tr></table></figure>
<p>//Solution1: Two stack<br>public List<integer> postorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    Stack<treenode> reverseStack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        reverseStack.push(node);<br>        if(node.left!=null) stack.push(node.left);<br>        if(node.right!=null) stack.push(node.right);<br>    }<br>    while(!reverseStack.isEmpty()) {<br>        list.add(reverseStack.pop());<br>    }<br>    return list;<br>}</treenode></treenode></integer></integer></p>
<p>//Solution2:<br>public List<integer> postorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode prev = null;<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.peek();<br>        //node.left==null &amp;&amp; node.right==null表明node为叶节点<br>        //prev!=null &amp;&amp; prev==node.left 表明左子树遍历完，右子树为空<br>        //prev!=null &amp;&amp; prev==node.right 表明右子树遍历完<br>        //prev!=node.left&amp;&amp;prev!=node.right表明stack已经连续输出节点到另一分支<br>        if((node.left==null &amp;&amp; node.right==null)||(prev!=null &amp;&amp; (prev == node.left || prev==node.right))) {<br>            node = stack.pop();<br>            list.add(node.val);<br>            prev = node;<br>        }else {<br>            if(node.right!=null) stack.push(node.right);<br>            if(node.left!=null) stack.push(node.left);<br>        }<br>    }<br>    return list;<br>}</treenode></integer></integer></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="attribute">4.分层遍历二叉树（按层次从上往下，从左往右）</span>: levelTraversal, levelTraversalRec（递归解法）</div><div class="line"></div><div class="line"><span class="qml">LeetCode - <span class="number">102.</span>Binary Tree Level Order Traversal </span></div><div class="line"></div><div class="line">递归解法：     </div><div class="line">记录每层个数，用层数去比较大lists的<span class="built_in">size</span>，如果<span class="built_in">size</span>等于层数，则需要添加一个新的<span class="built_in">list</span>用于记录当前层的nodes，如果<span class="built_in">size</span>小于层数，则拿出lists中相对应层数的<span class="built_in">list</span>去添加nodes.</div></pre></td></tr></table></figure>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();
    helper(lists, root,0);
    return lists;
}
void helper(List&lt;List&lt;Integer&gt;&gt; lists, TreeNode node, int level) {
    if(node == null) return;
    //add a new list to the new level of nodes
    if(lists.size() == level) lists.add(new ArrayList&lt;Integer&gt;());
    List&lt;Integer&gt; temp = lists.get(level);
    temp.add(node.val);
    helper(lists, node.left,level+1);
    helper(lists, node.right,level+1);

}
</code></pre><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法：    </div><div class="line">使用<span class="built_in">Queue</span>实现BFS</div></pre></td></tr></table></figure>
<p>//Traverse tree use BFS<br>public void levelTraversal(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>}</treenode></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="http"><span class="attribute">5.将二叉查找树变为有序的双向链表</span>: convertBST2DLLRec, convertBST2DLL</span></div><div class="line"></div><div class="line"><span class="autoit">LeetCode - <span class="number">114.</span>Flatten <span class="built_in">Binary</span> Tree <span class="keyword">to</span> Linked List </span></div><div class="line"></div><div class="line">递归解法：     </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回           </div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点, 把根节点的左子树移到右边，左边致为<span class="literal">null</span>,把根节点的原右子树放到原左子树的最右边</div></pre></td></tr></table></figure>
<pre><code>public void flatten(TreeNode root) {
    if(root == null) return;

    flatten(root.left);
    flatten(root.right);

    TreeNode right = root.right;
    root.right = root.left;
    root.left = null;
    TreeNode cur = root;
    while(cur.right!=null) cur = cur.right;
    cur.right = right;

}
</code></pre><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line"><span class="number">1</span>. 依次遍历右节点</div><div class="line"><span class="number">2</span>. 每次把current <span class="keyword">node</span> <span class="title">的右子树放到左子树的最右边，然后把左子树放到右边之后，把左边致为null</span></div></pre></td></tr></table></figure>
<p>public void flatten(TreeNode root) {<br>        if(root == null) return;<br>        while(root!=null) {<br>            if(root.left==null){<br>                root = root.right;<br>                continue;<br>            }<br>            TreeNode left = root.left;<br>            while(left.right!=null) {<br>                left = left.right;<br>            }<br>            left.right = root.right;<br>            root.right = root.left;<br>            root.left = null;<br>        }</p>
<p>}<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="lsl"><span class="number">6.</span>求二叉树第K层的节点个数：getNodeNumKthLevelRec, getNodeNumKthLevel</span></div><div class="line">递归解法：即把问题分解的过程    </div><div class="line">(<span class="number">1</span>) 如果current node为null 或者 k为<span class="number">0</span>，返回<span class="number">0.</span></div><div class="line">(<span class="number">2</span>) 如果二叉树不为空且k为<span class="number">1</span>，则返回<span class="number">1.</span></div><div class="line">(<span class="number">3</span>) 如果二叉树不为空且k&gt;<span class="number">1</span>, 则返回 左子树+右子树 的个数.</div></pre></td></tr></table></figure></p>
<p>public int getNodeNumKthLevel(TreeNode root, int k) {<br>    if(root == null || k==0) return 0;<br>    if(k==1) return 1;<br>    return  getNodeNumKthLevel(root.left,k-1) + getNodeNumKthLevel(root.right,k-1);<br>}</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line"><span class="bullet">1. </span>使用BFS, 用Queue去存储每一层节点</div><div class="line"><span class="bullet">2. </span>返回某层节点数，即size of Queue</div></pre></td></tr></table></figure>
<p>//Traverse tree use BFS<br>public int getNodeNumKthLevel(TreeNode root, int k) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    int result = 0;<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        if(–k == 0){<br>            result = size;<br>            break;<br>        }<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>    return result;<br>}</treenode></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">7.</span>求二叉树中叶子节点的个数：getNodeNumLeafRec, getNodeNumLeaf </div><div class="line">递归解法：即把问题分解的过程    </div><div class="line">(<span class="number">1</span>) 如果二叉树为null，返回<span class="number">0</span></div><div class="line">(<span class="number">2</span>) 如果二叉树不为空且其左右子树均为null，则返回<span class="number">1.</span> 叶子数 = 左子树叶子数 + 右子树叶子数</div></pre></td></tr></table></figure>
<p>public int getNodeNumLeafRec(TreeNode root) {<br>    if(root == null) return 0;<br>    if(root.right==null &amp;&amp; root.left==null) return 1;<br>    return  getNodeNumLeafRec(root.left) + getNodeNumLeafRec(root.right);<br>}</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line"><span class="number">1</span>. 使用BFS, 用Queue去存储每一层节点</div><div class="line"><span class="number">2</span>. 判断每个<span class="keyword">node</span><span class="title">是否含有左子树和右子树，如果没有则 叶子数+1</span></div></pre></td></tr></table></figure>
<p>//Traverse tree use BFS<br>public int getNodeNumKthLevel(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left==null &amp;&amp; node.right==null)count++;<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>    return count;<br>}</treenode></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="lsl"><span class="number">8.</span>判断两棵二叉树是否相同的树：isSameRec, isSame</span></div><div class="line"></div><div class="line">LeetCode - <span class="number">100.</span>Same Tree     </div><div class="line"></div><div class="line">递归解法：    </div><div class="line">(<span class="number">1</span>) 如果两个树都为空，返回true. 如果其中有一个节点为空或者两个节点的值不等，返回false. </div><div class="line">(<span class="number">2</span>) 递归遍历左子树和右子树，重复（<span class="number">1</span>）</div></pre></td></tr></table></figure>
<pre><code>public boolean isSameTree(TreeNode p, TreeNode q) {
    if(p==null &amp;&amp; q==null) return true;
    if(p==null || q==null) return false;
    if(p.val!=q.val) return false;
    if(p.val==q.val) return isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);
}
</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line"><span class="bullet">1. </span>对两个树同时使用先序遍历</div><div class="line"><span class="bullet">2. </span>每次比较两个点</div></pre></td></tr></table></figure>
<p>public boolean isSameTree(TreeNode p, TreeNode q) {        if(p==null &amp;&amp; q==null) return true;<br>        if(p==null || q==null) return false;<br>        Stack<treenode> s1 = new Stack&lt;&gt;();<br>        Stack<treenode> s2 = new Stack&lt;&gt;();<br>        s1.push(p);<br>        s2.push(q);<br>        while(!s1.isEmpty() &amp;&amp; !s2.isEmpty()) {<br>            TreeNode node1 = s1.pop();<br>            TreeNode node2 = s2.pop();<br>            if(node1==null &amp;&amp; node2==null) continue;<br>            if(node1!=null &amp;&amp; node2!=null &amp;&amp; node1.val==node2.val) {<br>                s1.push(node1.left);<br>                s1.push(node1.right);<br>                s2.push(node2.left);<br>                s2.push(node2.right);<br>            } else {<br>                return false;<br>            }<br>        }<br>        return true;<br>    }</treenode></treenode></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="armasm"><span class="number">9</span>.判断二叉树是不是平衡二叉树：<span class="keyword">isBalanced </span></span></div><div class="line"></div><div class="line"><span class="symbol">LeetCode</span> - <span class="number">110</span>.<span class="keyword">Balanced </span><span class="keyword">Binary </span>Tree</div><div class="line"></div><div class="line">递归解法<span class="number">1</span>：O(NlogN)    </div><div class="line">遍历每个点，每次都比较其左子树和右子树的高度</div></pre></td></tr></table></figure>
<pre><code>public boolean isBalanced(TreeNode root) {
    if(root==null) return true;
    if(Math.abs(getDepth(root.left)-getDepth(root.right))&gt;1) return false;
    return isBalanced(root.left) &amp;&amp; isBalanced(root.right);
}

int getDepth(TreeNode node) {
    if(node==null) return 0;
    return Math.max(getDepth(node.left),getDepth(node.right))+1;
}
</code></pre><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">递归解法<span class="number">2</span>： </div><div class="line">   </div><div class="line"><span class="number">1.</span> 自下而上，每次比较左子树和右子树，如果两边高度大于<span class="number">1</span>，则返回<span class="number">-1</span>。如果不是，则返回高度，供父节点使用。</div><div class="line"><span class="number">2.</span> 如果有一边是<span class="number">-1</span>，就直接向上，不用再求高度。</div></pre></td></tr></table></figure>
<p>public boolean isBalanced(TreeNode root) {            if(getDepth(root)==-1) return false;<br>        return true;<br>    }</p>
<pre><code>int getDepth(TreeNode node) {
    if(node==null) return 0;

    int leftDepth = getDepth(node.left);
    if(leftDepth==-1) return -1;

    int rightDepth = getDepth(node.right);
    if(rightDepth==-1) return -1;

    int diff = Math.abs(leftDepth-rightDepth);
    if(diff&gt;1) {
        return -1;
    } else {
        return Math.max(leftDepth,rightDepth) + 1;
    }
}
</code></pre><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">10.</span>求二叉树的镜像（破坏和不破坏原来的树两种情况）：</div><div class="line">     mirrorRec, mirrorCopyRec         </div><div class="line">     mirror, mirrorCopy   </div><div class="line"></div><div class="line">破坏原来的树     </div><div class="line">递归解法：   </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回null.</div><div class="line">(<span class="number">2</span>) 如果二叉树不为空, 无论有没有左右子树，交换他们的位置. 即自底向上依次调换所有左右子树位置。</div></pre></td></tr></table></figure>
<pre><code>public TreeNode mirrorRec(TreeNode root) {
    if(root==null) return null;
    TreeNode left = mirrorRec(root.left);
    TreeNode right = mirrorRec(root.right);
    root.right = left;
    root.left = right;
    return root;
}
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">使用BFS,每次遍历一个点都交换它左右子树的位置</div></pre></td></tr></table></figure>
<p>public TreeNode mirror(TreeNode root) {<br>    if(root == null) return null;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        TreeNode node = queue.poll();<br>        if(node.left==null &amp;&amp; node.right==null) continue;<br>        TreeNode left = node.left;<br>        node.left = node.right;<br>        node.right = left;<br>        if(node.left!=null) queue.add(node.left);<br>        if(node.right!=null) queue.add(node.right);</treenode></p>
<pre><code>}
return root;
</code></pre><p>}</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">不破坏原来的树     </div><div class="line">递归解法：   </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回null.</div><div class="line">(<span class="number">2</span>) 如果二叉树不为空, 使用先序遍历，首先创建新的节点，然后左右颠倒构造新的二叉树</div></pre></td></tr></table></figure>
<pre><code>public TreeNode mirrorCopyRec(TreeNode root) {
    if(root==null) return null;    
    TreeNode newRoot = new TreeNode(root.val);
    newRoot.left = mirrorRec(root.right);
    newRoot.right = mirrorRec(root.left);
    return newRoot;
}
</code></pre><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">使用Pre-<span class="keyword">Order</span>, 保持两个<span class="keyword">stack</span>，使新创建的点与原来的树保持一一对应.</div></pre></td></tr></table></figure>
<p>public TreeNode mirror(TreeNode root) {<br>    if(root == null) return null;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    Stack<treenode> newStack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode newRoot = new TreeNode(root.val);<br>    newStack.push(newRoot);<br>    while(!queue.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        TreeNode newNode = newStack.pop();<br>        if(node.left!=null) {<br>            stack.push(node.left);<br>            newNode.rihgt = newTreeNode(node.left.val);<br>            stack.push(newNode.right);<br>        }<br>        if(node.right!=null) {<br>            stack.push(node.right);<br>            newNode.left = newTreeNode(node.right.val);<br>            stack.push(newNode.left);<br>        }<br>    }<br>    return newRoot;<br>}</treenode></treenode></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">10.1</span> 判断两个树是否互相镜像：isMirrorRec isMirror</div><div class="line"></div><div class="line">递归解法：   </div><div class="line">(<span class="number">1</span>) 如果两个二叉树都为空，返回<span class="literal">true</span>.</div><div class="line">(<span class="number">2</span>) 如果只有其中一个二叉树为空，返回<span class="literal">false</span>.</div><div class="line">(<span class="number">3</span>) 若果两个节点的val不相等，返回<span class="literal">false</span>.</div><div class="line">(<span class="number">4</span>) 比较一个树的左子树和另个树的右子树，以及一个树的右子树和另个树的左子树.</div></pre></td></tr></table></figure>
<pre><code>public boolean isMirrorRec(TreeNode p, TreeNode q) {
    if(p==null &amp;&amp; q==null) return true; 
    if(p==null || q==null) return false;
    if(p.val != q.val) return false;
    return isMirrorRec(p.left,q.right) &amp;&amp; isMirrorRec(p.right,q.left);
}
</code></pre><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">使用Pre-<span class="keyword">Order</span>,每次遍历交叉树的值</div></pre></td></tr></table></figure>
<p>public boolean isMirror(TreeNode p, TreeNode q) {<br>    if(p == null &amp;&amp; q==null) return true;<br>    if(p == null || q==null) return false;<br>    Stack<treenode> stack1 = new Stack&lt;&gt;();<br>    Stack<treenode> stack2 = new Stack&lt;&gt;();<br>    stack1.push(p);<br>    stack2.push(q);<br>    while(!p.isEmpty()&amp;&amp;!q.isEmpty()) {<br>        TreeNode node1 = stack1.pop();<br>        TreeNode node2 = stack2.pop();<br>        if(node1.val != node.val) return false;<br>        if((node1.left==null&amp;&amp;node2.rihgt!=null)||(node1.left!=null&amp;&amp;node2.rihgt==null)) return false;<br>        if(node1.left!=null &amp;&amp; node2.right!=null) {<br>            stack1.push(node1.left);<br>            stack2.push(node2.right);<br>        }<br>        if((node1.rihgt==null&amp;&amp;node2.left!=null)||(node1.right!=null&amp;&amp;node2.left==null)) return false;<br>        if(node1.rihgt!=null &amp;&amp; node2.left!=null) {<br>            stack1.push(node1.right);<br>            stack2.push(node2.left);<br>        }<br>    }<br>    return true;<br>}</treenode></treenode></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="lsl"><span class="number">11.</span>求二叉树中两个节点的最低公共祖先节点：     </span></div><div class="line">       getLastCommonParent    求解最小公共祖先, 使用<span class="type">list</span>来存储path.     </div><div class="line">       getLastCommonParentRec     递归算法 .      </div><div class="line">       </div><div class="line">LeetCode - <span class="number">236.</span>Lowest Common Ancestor of a Binary Tree    </div><div class="line"></div><div class="line">递归解法：   </div><div class="line">(<span class="number">1</span>) 如果从根节点出发，分别从左右两边找到两个节点，则LastCommonParrent是根节点</div><div class="line">(<span class="number">2</span>) 如果从根节点的左子树出发，找到两节点，则LastCommonParrent在左子树</div><div class="line">(<span class="number">3</span>) 如果从根节点的右子树出发，找到两节点，则LastCommonParrent在右子树</div></pre></td></tr></table></figure>
<pre><code>//Solution1:
public TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) {
    if(findNode(root.left,p)) {
        if(findNode(root.left,q)) {
            return getLastCommonParentRec(root.left,p,q);
        }else {
            return root;
        }
    }else {
        if(findNode(root.right,q)) {
            return getLastCommonParentRec(root.right,p,q);
        }else {
            return root;
        }
    }
}

boolean findNode(TreeNode root, TreeNode node) {
    if(root==null || node==null) return false;

    if(root==node) return true;

    boolean found = findNode(root.left,node);
    if(!found) {
        found = findNode(root.right,node);
    }
    return found;
}
</code></pre><p>//Solution2:<br>public TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) {<br>    if(root==null) return null;<br>    if(root==p || root==q) return root;<br>    TreeNode commonLeft = getLastCommonParentRec(root.left,p,q);<br>    TreeNode commonRight = getLastCommonParentRec(root.right,p,q);<br>    if(commonLeft!=null &amp;&amp; commonRight!=null) return root;<br>    if(commonLeft!=null) return commonLeft;<br>    return commonRight;<br>}</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line"></div><div class="line"><span class="number">1.</span> 分别从根节点出发，查找到达两个节点的路径，用<span class="type">list</span>保存</div><div class="line"><span class="number">2.</span> 然后同时比较两个<span class="type">list</span>中的点，找出最后相同的两个点（两个<span class="type">list</span>前面的点都相同）</div></pre></td></tr></table></figure>
<p>public TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) {<br>    ArrayList<treenode> list1 = new ArrayList&lt;&gt;();<br>    ArrayList<treenode> list2 = new ArrayList&lt;&gt;();<br>    boolean found1 = findPath(root,p,list1);<br>    boolean found2 = findPath(root,q,list2);<br>    if(!found1 || !found2) return null;</treenode></treenode></p>
<pre><code>TreeNode result = null;
for(int i=0;i&lt;Math.min(list1.size(),list2.size());i++) {
    if(list1.get(i)==list2.get(i)){
        result = list1.get(i);
    }else break;
}
return result;
</code></pre><p>}</p>
<p>boolean findPath(TreeNode root, TreeNode node, ArrayList<treenode> list) {<br>    if(root==null || node==null) return false;<br>    list.add(root);<br>    if(root == node) return true;<br>    boolean found = findPath(root.left,node,list);<br>    if(!found) {<br>        found = findPath(root.right,node,list);<br>    }<br>    if(!found) list.remove(root);<br>    return found;<br>}</treenode></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">       </div><div class="line"><span class="number">12.</span>求二叉树中节点的最大距离：getMaxDistanceRec     </div><div class="line"></div><div class="line">递归法：      </div><div class="line">(<span class="number">1</span>)求最大距离有两种情况：一是两个最大深度相加，它分别位于根节点的两侧；一是某个子节点下两个分支距离的和最大       </div><div class="line">(<span class="number">2</span>)创建一个类去记录最大距离和最大深度，每次记录每个点的深度，以及最长距离</div></pre></td></tr></table></figure>
<p>public int getMaxDistanceRec(TreeNode root) {<br>    Distance dis = getDistance(root);<br>    return dis.maxDistance;<br>}</p>
<p>private Distance getDistance(TreeNode node) {<br>    //最底一层，深度为0<br>    if(node==null){<br>        Distance empty = new Distance(0,-1);<br>        return empty;<br>    }</p>
<pre><code>Distance left = getDistance(node.left);
Distance right = getDistance(node.right);

Distance dis = new Distance();
dis.maxDepth = Math.max(left.maxDepth,right.maxDepth)+1;
dis.maxDistance = Math.max(left.maxDepth+right.maxDepth+2,Math.max(left.maxDistance,right.maxDistance));
return dis;
</code></pre><p>}</p>
<p>class Distance {<br>    int maxDistance;<br>    int maxDepth;<br>    public Distance(){}<br>    public Distance(int maxDistance,int maxDepth){<br>        this.maxDistance = maxDistance;<br>        this.maxDepth = maxDepth;<br>    }<br> }</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">13.</span>由前序遍历序列和中序遍历序列重建二叉树：rebuildBinaryTreeRec</div><div class="line"></div><div class="line">LeetCode - <span class="number">105.</span> Construct Binary Tree from Preorder and Inorder Traversal     </div><div class="line"></div><div class="line"></div><div class="line">递归解法：</div><div class="line"></div><div class="line"><span class="number">1.</span> 由前序遍历可以知道第一个点是root，接下来几个点是左子树的点，之后几个是右子树的点, 特点是大体排列次序按照每个树的根节点顺序排列。</div><div class="line"><span class="number">2.</span> 由中序遍历可以知道root点左边的都是左子树的点，右边都是右子树的点.可以得出左子树和右子树节点数</div></pre></td></tr></table></figure>
<p>public TreeNode rebuildBinaryTreeRec(int[]preorder,int[]inorder) {<br>    return buildTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1);<br>}</p>
<p>TreeNode buildTree(int[]preorder,int preStart, int preEnd, int[]inorder, int inStart, int inEnd) {<br>    if(preStart &gt; preEnd) return null;<br>    int rootVal = preorder[preStart];<br>    int inRoot=-1;<br>    for(int i=inStart,j=inEnd; i&lt;=j; i++,j–) {<br>        if(inorder[i] == rootVal) {<br>            inRoot = i;<br>            break;<br>        }else if(inorder[j] == rootVal){<br>            inRoot = j;<br>            break;<br>        }<br>    }<br>    TreeNode root = new TreeNode(rootVal);<br>    root.left = buildTree(preorder,preStart+1,preStart+(inRoot-inStart), inorder,inStart,inRoot-1);<br>    root.right = buildTree(preorder,preEnd-(inEnd-inRoot)+1,preEnd,inorder,inRoot+1,inEnd);<br>    return root;<br>}</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="lsl"></span></div><div class="line"><span class="number">14.</span>判断二叉树是不是完全二叉树：isCompleteBinaryTree, isCompleteBinaryTreeRec</div><div class="line"></div><div class="line">迭代解法： </div><div class="line">(<span class="number">1</span>)使用BFS遍历节点，每层节点中，如果遇到左右子树为空时，或者遇到的第一个左子树不为空但右子树为空的情况，则后面所有的左右子树必须为空。即为完全二叉树。     </div><div class="line">(<span class="number">2</span>)设立一个标志，如果有个节点的左右子树为空，则之后所有节点的子树必须为空。</div></pre></td></tr></table></figure>
<p>public boolean isCompleteBinaryTree(TreeNode root) {<br>    if(root == null) return false;<br>    Queue<treenode> queue = new Queue&lt;&gt;();<br>    queue.add(root);<br>    boolean flag = true;<br>    while(!queue.isEmpty()) {<br>        TreeNode node = queue.poll();<br>        if(flag) {<br>            if(node.left==null &amp;&amp; node.right==null) flag = false;<br>            else if(node.left==null &amp;&amp; node.right!=null) return false;<br>            else if(node.left!=null &amp;&amp; node.right==null) {<br>                flag = false;<br>                queue.add(node.left);<br>            }else {<br>                queue.add(node.left);<br>                queue.add(node.right);<br>            }</treenode></p>
<pre><code>    }else {
        if(node.left!=null || node.right!=null) return false;
    }
}
return true;
</code></pre><p>}</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="livecodeserver"><span class="number">15.</span>找出二叉树中最长连续子串(即全部往左的连续节点，或是全部往右的连续节点）findLongest</span></div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line"><span class="comment">## 学习后总结：</span></div><div class="line"><span class="comment">### When to use Pre-Order, In-Order, Post-Order</span></div><div class="line"></div><div class="line">- Pre-Order: Recursively, this is `self, left, <span class="literal">right</span>`. From root node <span class="built_in">to</span> <span class="literal">right</span> most node. Firstly, <span class="keyword">if</span> you know you need <span class="built_in">to</span> explore <span class="keyword">the</span> roots <span class="keyword">before</span> inspecting <span class="keyword">any</span> leaves, you should pick pre-order because you will encounter all <span class="keyword">the</span> roots <span class="keyword">before</span> all <span class="keyword">of</span> <span class="keyword">the</span> leaves.  Secondly, <span class="keyword">if</span> you want <span class="built_in">to</span> simply print out <span class="keyword">the</span> hierachical <span class="built_in">format</span> <span class="keyword">of</span> <span class="keyword">the</span> tree <span class="keyword">in</span> <span class="keyword">a</span> linear <span class="built_in">format</span>, use preorder traversal.</div></pre></td></tr></table></figure>
<ul>
<li>Root<ul>
<li>A<ul>
<li>B</li>
<li>C</li>
</ul>
</li>
<li>D<ul>
<li>E</li>
<li>F<br>  -G    </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- Post-Order: Recursively, this is`left, right, self`. From left most <span class="keyword">node</span> <span class="title">to</span> right most <span class="keyword">node</span>.  <span class="title">If</span> you know you need to explore all the leaves before any nodes, you should pick post-<span class="keyword">order</span> <span class="title">because</span> you don't waster any time inspecting roots <span class="keyword">in</span> search for leaves. 或者应用在：树的删除。为了释放树结构的内存，某节点在被释放以前，其左右子树的节点首先应当被释放掉。</div><div class="line">- <span class="keyword">In</span>-Order: Recursively, this is`left, self, right`. From left most <span class="keyword">node</span> <span class="title">to</span> right most <span class="keyword">node</span>. <span class="title">If</span> you know that the tree has an inherent sequence, <span class="keyword">and</span> you want to flatten the tree back into the original sequence(simply process the items <span class="keyword">in</span> the <span class="keyword">defined</span> order).</div></pre></td></tr></table></figure>
<p>For example, you have a BST of a list of number, inorder traversal would print them out in ascending order.</p>
<pre><code>+
</code></pre><p>  /      \<br> A     *<br>      /  \<br>     B    C</p>
<p>Output: A + B * C</p>
<p>If you want to evaluate the expression, you traverse the tree in postorder, applying each operator to the values from each of its sub-trees.      </p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="oxygene">### When <span class="keyword">to</span> use BFS <span class="keyword">and</span> DFS, the relationship between DFS <span class="keyword">and</span> PreOrder</span></div><div class="line"></div><div class="line">DFS 包括: </div><div class="line">  </div><div class="line"><span class="number">1</span>. Pre-<span class="keyword">Order</span>, <span class="keyword">In</span>-<span class="keyword">Order</span>, Post-<span class="keyword">Order</span></div><div class="line"><span class="number">2</span>. Divide &amp; Conquer</div><div class="line"></div><div class="line">Notice：     </div><div class="line">Sometimes it <span class="keyword">is</span> easy <span class="keyword">to</span> figure <span class="keyword">out</span> question <span class="keyword">using</span> Recursion.  So interviewer wants you <span class="keyword">to</span> use Iterative solution.  因为这里，递归的方法和变量都是存储在Stack中的，现在就是想考验你去实现栈的内部工作原理，使用iteration 都需要去借助一个数据结构来完成recursion的方法。</div><div class="line"></div><div class="line">DFS Template:</div><div class="line"></div><div class="line"><span class="number">1</span>.Recursively Traverse</div></pre></td></tr></table></figure>
<p>public void traversal(TreeNode root) {<br>    if(roo==null) return;</p>
<pre><code>traversal(root.left);

traversal(root.right);
</code></pre><p>}</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span><span class="selector-class">.Divide</span> &amp; Conquer</div></pre></td></tr></table></figure>
<p>public ResultType traversal(TreeNode root) {<br>    if(root==null) {<br>        return null;<br>    }</p>
<pre><code>//Divide
ResultType left = traversal(root.left);
ResultType right = traversal(root.right);

//Conquer
ResultType result = Merge from left to right
return result;
</code></pre><p>}</p>
<p>```</p>
<h3 id="How-to-think-over-Divide-amp-Conquer"><a href="#How-to-think-over-Divide-amp-Conquer" class="headerlink" title="How to think over Divide&amp;Conquer"></a>How to think over Divide&amp;Conquer</h3></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://xinli90.com/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/" data-id="citlkejs2002m69u0quz2gpuq" class="article-share-link">Share</a><div class="tags"><a href="/tags/Seeking-Job/">Seeking Job</a></div><div class="post-nav"><a href="/2016/08/22/Day10-Algorithm-about-Itetation-and-Recursion/" class="pre">Day10 Algorithm about Itetation and Recursion</a><a href="/2016/08/19/Two-Sum-III-Data-structure-design/" class="next">Two Sum III - Data structure design</a></div><div id="disqus_thread"><script>var disqus_shortname = 'xinli';
var disqus_identifier = '2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/';
var disqus_title = 'Day9 Algorithm about Binary Tree';
var disqus_url = 'http://xinli90.com/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//xinli.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Seeking-Job/" style="font-size: 15px;">Seeking Job</a> <a href="/tags/J2EE/" style="font-size: 15px;">J2EE</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AWS/">AWS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure/">Data Structure</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Geek/">Geek</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/J2EE/">J2EE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">74</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Multithreading/">Multithreading</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/class-design/">class design</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/25/Recover-Binary-Search-Tree/">Recover Binary Search Tree</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/25/Day14-Introduction-to-AWS/">Day14 Introduction to AWS</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/22/Longest-Common-Prefix/">Longest Common Prefix</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/22/Longest-Palindromic-Substring/">Longest Palindromic Substring</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/Day13-Tradeoff-of-Different-Language/">Day13 Tradeoff of Different Language</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/String-to-Integer-atoi/">String to Integer (atoi)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/Reverse-Integer/">Reverse Integer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/Majority-Element/">Majority Element</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/ZigZag-Conversion/">ZigZag Conversion</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/Excel-Sheet-Column-Title/">Excel Sheet Column Title</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//xinli.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="null" title="null" target="_blank"></a><ul></ul><a href="null" title="null" target="_blank"></a><ul></ul><a href="null" title="null" target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Xinli's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-83440669-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>