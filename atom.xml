<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinli&#39;s Blog</title>
  <subtitle>Coding World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinli90.com/"/>
  <updated>2016-09-03T03:44:02.000Z</updated>
  <id>http://xinli90.com/</id>
  
  <author>
    <name>Xinli Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Day11 Multithreading</title>
    <link href="http://xinli90.com/2016/09/02/Day11-Multithreading/"/>
    <id>http://xinli90.com/2016/09/02/Day11-Multithreading/</id>
    <published>2016-09-03T03:34:01.000Z</published>
    <updated>2016-09-03T03:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇关于Multithreading多线程的原理与应用.</p>
<h2 id="攻略模板"><a href="#攻略模板" class="headerlink" title="攻略模板"></a>攻略模板</h2><ul>
<li>回忆多线程特性</li>
<li>实现多线程结构</li>
<li>实战训练使用该多线程</li>
<li>总结该多线程特点，并总结算法题</li>
</ul>
<h2 id="自己回忆"><a href="#自己回忆" class="headerlink" title="自己回忆"></a>自己回忆</h2><h2 id="实现数据结构"><a href="#实现数据结构" class="headerlink" title="实现数据结构"></a>实现数据结构</h2><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><p>Solution1:</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Class</span> A <span class="comment">&#123;</span></div><div class="line">	private final A a;</div><div class="line">	public A()&#123;</div><div class="line">		a = new A();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> A getInstance() <span class="comment">&#123;</span></div><div class="line">		return a;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="学习后总结"><a href="#学习后总结" class="headerlink" title="学习后总结"></a>学习后总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇关于Multithreading多线程的原理与应用.&lt;/p&gt;
&lt;h2 id=&quot;攻略模板&quot;&gt;&lt;a href=&quot;#攻略模板&quot; class=&quot;headerlink&quot; title=&quot;攻略模板&quot;&gt;&lt;/a&gt;攻略模板&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;回忆多线程特性&lt;/li&gt;
&lt;li&gt;实现多
    
    </summary>
    
      <category term="Multithreading" scheme="http://xinli90.com/categories/Multithreading/"/>
    
    
      <category term="Seeking Job" scheme="http://xinli90.com/tags/Seeking-Job/"/>
    
  </entry>
  
  <entry>
    <title>Clone Graph</title>
    <link href="http://xinli90.com/2016/08/30/Clone-Graph/"/>
    <id>http://xinli90.com/2016/08/30/Clone-Graph/</id>
    <published>2016-08-30T17:50:49.000Z</published>
    <updated>2016-08-30T21:51:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="external">Leetcode-Clone Graph</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>OJ’s undirected graph serialization:     </p>
<p>Nodes are labeled uniquely.</p>
<p>We use <code>#</code> as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.</p>
<p>As an example, consider the serialized graph <code>{0,1,2#1,2#2,2}</code>.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.   </p>
<ol>
<li>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.</li>
<li>Second node is labeled as 1. Connect node 1 to node 2.</li>
<li>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.    </li>
</ol>
<p>Visually, the graph looks like the following:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   <span class="number">1</span></div><div class="line">  / <span class="string">\</span></div><div class="line"> /   <span class="string">\</span></div><div class="line"><span class="number">0</span> --- <span class="number">2</span></div><div class="line">     / <span class="string">\</span></div><div class="line">     <span class="string">\_/</span></div></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><ol>
<li>Use BFS</li>
<li>Queue + HashMap</li>
<li>In HashMap, key is label, value is new Object.  So each time we clone each node through HashMap.</li>
</ol>
<h4 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h4><ol>
<li>Use DFS + Recursive Solution</li>
<li>If node is empty, return null.</li>
<li>If there is already the node in HashMap, return it.</li>
<li>Else traverse neighbor nodes, clone it and store it into HashMap and recursively add new node into its neighbors.</li>
</ol>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for undirected graph.</div><div class="line"> * class UndirectedGraphNode &#123;</div><div class="line"> *     int label;</div><div class="line"> *     List&lt;UndirectedGraphNode&gt; neighbors;</div><div class="line"> *     UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">public class Solution1 &#123;</div><div class="line">    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123;</div><div class="line">        <span class="keyword">if</span>(node == null) <span class="built_in">return</span> null;    </div><div class="line">    	Queue&lt;UndirectedGraphNode&gt; queue = <span class="built_in">new</span> ArrayDeque&lt;&gt;();</div><div class="line">    	HashMap&lt;Integer,UndirectedGraphNode&gt; <span class="built_in">map</span> = <span class="built_in">new</span> HashMap&lt;&gt;();</div><div class="line">    	queue.offer(node);</div><div class="line">    	UndirectedGraphNode newNode = <span class="built_in">new</span> UndirectedGraphNode(node.<span class="built_in">label</span>);</div><div class="line">    	<span class="built_in">map</span>.<span class="built_in">put</span>(newNode.<span class="built_in">label</span>,newNode);</div><div class="line">    	</div><div class="line">    	<span class="keyword">while</span>(!queue.isEmpty()) &#123;</div><div class="line">    		UndirectedGraphNode input = queue.poll();</div><div class="line">    		List&lt;UndirectedGraphNode&gt; neighbor = input.<span class="built_in">neighbors</span>;</div><div class="line">    		<span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;neighbor.size(); i++) &#123;</div><div class="line">    			int <span class="built_in">label</span> = neighbor.<span class="built_in">get</span>(i).<span class="built_in">label</span>;</div><div class="line">    			<span class="keyword">if</span>(!<span class="built_in">map</span>.containsKey(<span class="built_in">label</span>)) &#123;</div><div class="line">    				<span class="built_in">map</span>.<span class="built_in">put</span>(<span class="built_in">label</span>,<span class="built_in">new</span> UndirectedGraphNode(<span class="built_in">label</span>));</div><div class="line">    				queue.offer(neighbor.<span class="built_in">get</span>(i));</div><div class="line">    			&#125;</div><div class="line">    			<span class="built_in">map</span>.<span class="built_in">get</span>(input.<span class="built_in">label</span>).<span class="built_in">neighbors</span>.add(<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">label</span>));</div><div class="line">    		&#125;</div><div class="line">    	&#125;</div><div class="line">    	<span class="built_in">return</span> newNode;    </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Solution2 &#123;</div><div class="line">	HashMap&lt;Integer,UndirectedGraphNode&gt; <span class="built_in">map</span> = <span class="built_in">new</span> HashMap&lt;&gt;();</div><div class="line">    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123;</div><div class="line">    	<span class="keyword">if</span>(node == null) <span class="built_in">return</span> null;</div><div class="line">    	<span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(node.<span class="built_in">label</span>)) <span class="built_in">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(node.<span class="built_in">label</span>);</div><div class="line">    	UndirectedGraphNode newNode = <span class="built_in">new</span> UndirectedGraphNode(node.<span class="built_in">label</span>);</div><div class="line">    	<span class="built_in">map</span>.<span class="built_in">put</span>(newNode.<span class="built_in">label</span>,newNode);</div><div class="line">    	List&lt;UndirectedGraphNode&gt; neighbor = node.<span class="built_in">neighbors</span>;</div><div class="line">    	<span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;neighbor.size(); i++) &#123;</div><div class="line">    		newNode.<span class="built_in">neighbors</span>.add(cloneGraph(neighbor.<span class="built_in">get</span>(i)));</div><div class="line">    	&#125;</div><div class="line">    	<span class="built_in">return</span> newNode;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/clone-graph/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetcode-Clone Graph&lt;/a&gt;.&lt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Insert Delete GetRandom O(1)</title>
    <link href="http://xinli90.com/2016/08/30/Insert-Delete-GetRandom-O-1/"/>
    <id>http://xinli90.com/2016/08/30/Insert-Delete-GetRandom-O-1/</id>
    <published>2016-08-30T16:00:55.000Z</published>
    <updated>2016-08-30T22:47:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="external">Leetcode-Insert Delete GetRandom O(1)</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Design a data structure that supports all following operations in average O(1) time.</p>
<ol>
<li>insert(val): Inserts an item val to the set if not already present.</li>
<li>remove(val): Removes an item val from the set if present.</li>
<li>getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.</li>
</ol>
<p>Example:</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Init an empty set.</span></div><div class="line"><span class="type">RandomizedSet</span> randomSet = <span class="function"><span class="keyword">new</span> <span class="title">RandomizedSet</span>();</span></div><div class="line"></div><div class="line"><span class="comment">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</span></div><div class="line"><span class="title">randomSet</span>.<span class="title">insert</span>(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns false as 2 does not exist in the set.</span></div><div class="line"><span class="title">randomSet</span>.<span class="title">remove</span>(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// Inserts 2 to the set, returns true. Set now contains [1,2].</span></div><div class="line"><span class="title">randomSet</span>.<span class="title">insert</span>(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// getRandom should return either 1 or 2 randomly.</span></div><div class="line"><span class="title">randomSet</span>.<span class="title">getRandom</span>();</div><div class="line"></div><div class="line"><span class="comment">// Removes 1 from the set, returns true. Set now contains [2].</span></div><div class="line"><span class="title">randomSet</span>.<span class="title">remove</span>(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 2 was already in the set, so return false.</span></div><div class="line"><span class="title">randomSet</span>.<span class="title">insert</span>(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// Since 1 is the only number in the set, getRandom always return 1.</span></div><div class="line"><span class="title">randomSet</span>.<span class="title">getRandom</span>();</div></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><ol>
<li>Use HashMap and ArrayList</li>
<li>Dlete operation: 1. Swap the target to the last of list and remove the last element. This takes O(1) time. 2. Should update the value of the last element in HashMap.</li>
</ol>
<h4 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h4><ol>
<li>Keep two HashMap</li>
<li>One hashmap stores <value, location="">, another hashmap stores<location, value="">.</location,></value,></li>
<li>Dlete operation: Inorder to maintain the correct location, when delete one element from output HashMap, we need update the pair with the size of input as the key.  Then we need correspondingly update the value of this specific pair in input HashMap.</li>
<li>Random to get element from the second hashmap</li>
</ol>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Solution1</span></div><div class="line"><span class="keyword">public</span> class RandomizedSet &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">HashMap</span>&lt;Integer,Integer&gt; <span class="built_in">map</span>;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list;</div><div class="line">    </div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="keyword">public</span> RandomizedSet() &#123;</div><div class="line">        <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;Integer,Integer&gt;();</div><div class="line">        list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></div><div class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> insert(<span class="built_in">int</span> val) &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">map</span>.put(val,list.<span class="built_in">size</span>());</div><div class="line">            list.<span class="built_in">add</span>(val);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></div><div class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> remove(<span class="built_in">int</span> val) &#123;</div><div class="line">        <span class="keyword">if</span>(!<span class="built_in">map</span>.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">int</span> index = <span class="built_in">map</span>.<span class="built_in">get</span>(val);</div><div class="line">          </div><div class="line">            <span class="built_in">int</span> temp = list.<span class="built_in">get</span>(list.<span class="built_in">size</span>()<span class="number">-1</span>);                        </div><div class="line">            list.<span class="built_in">set</span>(index,temp);</div><div class="line">            <span class="built_in">map</span>.put(temp,index);</div><div class="line">            </div><div class="line">            <span class="built_in">map</span>.remove(val);</div><div class="line">            list.remove(list.<span class="built_in">size</span>()<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Get a random element from the set. */</span></div><div class="line">    <span class="keyword">public</span> <span class="built_in">int</span> getRandom() &#123;</div><div class="line">        Random rand = <span class="keyword">new</span> Random();</div><div class="line">        <span class="built_in">int</span> index = rand.nextInt(list.<span class="built_in">size</span>());</div><div class="line">        <span class="keyword">return</span> list.<span class="built_in">get</span>(index);</div><div class="line">    &#125;</div><div class="line">&#125;		</div><div class="line"></div><div class="line"><span class="comment">//Solution2</span></div><div class="line"><span class="keyword">public</span> class RandomizedSet &#123;</div><div class="line">	<span class="keyword">HashMap</span>&lt;Integer,Integer&gt; input;</div><div class="line">	<span class="keyword">HashMap</span>&lt;Integer,Integer&gt; output;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="keyword">public</span> RandomizedSet() &#123;</div><div class="line">        input = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;Integer,Integer&gt;();</div><div class="line">        output = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;Integer,Integer&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></div><div class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> insert(<span class="built_in">int</span> val) &#123;</div><div class="line">        <span class="keyword">if</span>(input.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="built_in">int</span> location = input.<span class="built_in">size</span>();</div><div class="line">        input.put(val,location);</div><div class="line">        output.put(location,val);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></div><div class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> remove(<span class="built_in">int</span> val) &#123;</div><div class="line">        <span class="keyword">if</span>(!input.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="built_in">int</span> location = input.<span class="built_in">get</span>(val);</div><div class="line">        <span class="built_in">int</span> insteadValue = output.<span class="built_in">get</span>(input.<span class="built_in">size</span>()<span class="number">-1</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//update the pair which the key is the last location</span></div><div class="line">        output.put(location,insteadValue);</div><div class="line">        input.put(insteadValue,location);</div><div class="line">        </div><div class="line">        <span class="comment">//remove the key with the last location</span></div><div class="line">        output.remove(input.<span class="built_in">size</span>()<span class="number">-1</span>);</div><div class="line">        input.remove(val);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Get a random element from the set. */</span></div><div class="line">    <span class="keyword">public</span> <span class="built_in">int</span> getRandom() &#123;</div><div class="line">        Random <span class="built_in">random</span> = <span class="keyword">new</span> Random();</div><div class="line">        <span class="built_in">int</span> index = <span class="built_in">random</span>.nextInt(input.<span class="built_in">size</span>());</div><div class="line">        <span class="keyword">return</span> output.<span class="built_in">get</span>(index);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Your RandomizedSet object will be instantiated and called as such:</div><div class="line"> * RandomizedSet obj = new RandomizedSet();</div><div class="line"> * boolean param_1 = obj.insert(val);</div><div class="line"> * boolean param_2 = obj.remove(val);</div><div class="line"> * int param_3 = obj.getRandom();</div><div class="line"> */</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/insert-delete-getrandom-o1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetcode-In
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Alien Dictionary</title>
    <link href="http://xinli90.com/2016/08/30/Alien-Dictionary/"/>
    <id>http://xinli90.com/2016/08/30/Alien-Dictionary/</id>
    <published>2016-08-30T14:04:07.000Z</published>
    <updated>2016-08-30T22:59:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/alien-dictionary/" target="_blank" rel="external">Leetcode-Alien Dictionary</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p>
<p>For example,<br>Given the following words in dictionary,</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[</div><div class="line">  <span class="string">"wrt"</span>,</div><div class="line">  <span class="string">"wrf"</span>,</div><div class="line">  <span class="string">"er"</span>,</div><div class="line">  <span class="string">"ett"</span>,</div><div class="line">  <span class="string">"rftt"</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>The correct order is: “wertf”.</p>
<p>Note:</p>
<ol>
<li>You may assume all letters are in lowercase.</li>
<li>If the order is invalid, return an empty string.</li>
<li>There may be multiple valid order of letters, return any one of them is fine.</li>
</ol>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><ol>
<li>BFS</li>
</ol>
<h4 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h4><ol>
<li>DFS</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution1 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">String</span> alienOrder(<span class="keyword">String</span>[] words) &#123;</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution2 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">String</span> alienOrder(<span class="keyword">String</span>[] words) &#123;</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/alien-dictionary/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetcode-Alien Dictio
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Sort Colors</title>
    <link href="http://xinli90.com/2016/08/30/Sort-Colors/"/>
    <id>http://xinli90.com/2016/08/30/Sort-Colors/</id>
    <published>2016-08-30T13:20:41.000Z</published>
    <updated>2016-08-30T17:52:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="external">Leetcode-Sort Colors</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><ol>
<li>Time complexity is O(n), space complexity is O(1)</li>
<li>Loop this array and count the frequency of each number.</li>
<li>Assign to original array one by one </li>
</ol>
<h4 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h4><p>Follow the first step of solution1, loop the count array instead of loop the nums array.</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> sortColors(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">		<span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">		<span class="keyword">int</span> [] <span class="keyword">count</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</div><div class="line">			<span class="keyword">count</span>[num]++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</div><div class="line">			<span class="keyword">while</span>(<span class="keyword">count</span>[<span class="keyword">index</span>]&lt;=<span class="number">0</span> &amp;&amp; <span class="keyword">index</span>&lt;<span class="number">3</span>)&#123;</div><div class="line">				<span class="keyword">index</span>++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(<span class="keyword">index</span>==<span class="number">3</span>) <span class="keyword">return</span>;</div><div class="line">			nums[i] = <span class="keyword">index</span>;</div><div class="line">			<span class="keyword">count</span>[<span class="keyword">index</span>]--;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">			</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> sortColors(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">		<span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">		<span class="keyword">int</span> [] <span class="keyword">count</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</div><div class="line">			<span class="keyword">count</span>[num]++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> <span class="keyword">index</span>=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">			<span class="keyword">while</span>(<span class="keyword">count</span>[i]&gt;<span class="number">0</span>)&#123;</div><div class="line">				nums[<span class="keyword">index</span>++] = i;</div><div class="line">				<span class="keyword">count</span>[i]--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/sort-colors/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetcode-Sort Colors&lt;/a&gt;.&lt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Lowest Common Ancestor of a Binary Tree</title>
    <link href="http://xinli90.com/2016/08/25/Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
    <id>http://xinli90.com/2016/08/25/Lowest-Common-Ancestor-of-a-Binary-Tree/</id>
    <published>2016-08-25T21:44:20.000Z</published>
    <updated>2016-08-28T20:21:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="external">Leetcode-Lowest Common Ancestor of a Binary Tree</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="external">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     _______3______</div><div class="line">    /              \</div><div class="line"> ___5__          ___1__</div><div class="line">/      \        /      \</div><div class="line"><span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></div><div class="line">      /  \</div><div class="line">      <span class="number">7</span>   <span class="number">4</span></div></pre></td></tr></table></figure>
<p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1-Recursive-solution"><a href="#Solution1-Recursive-solution" class="headerlink" title="Solution1: Recursive solution."></a>Solution1: Recursive solution.</h4><ol>
<li>If search from root and find two target nodes in different sides. Then the LCA is root.</li>
<li>If find two nodes in left subtree, then recursively search from the left of root.</li>
<li>If find two nodes in right subtree, then recursively search from the right of root.</li>
</ol>
<h4 id="Solution2-Recursive-solution"><a href="#Solution2-Recursive-solution" class="headerlink" title="Solution2: Recursive solution."></a>Solution2: Recursive solution.</h4><ol>
<li>If root is null, return null</li>
<li>If root is one of two nodes, return root.</li>
<li>Recurseively traverse left subtree and right subtree.</li>
<li>If both left subtree and right subtree get the specific node, then return root.</li>
<li>If one of subtree is null, return another subtree.</li>
</ol>
<h4 id="Solution3-Iterative-solution"><a href="#Solution3-Iterative-solution" class="headerlink" title="Solution3: Iterative solution."></a>Solution3: Iterative solution.</h4><ol>
<li>Use List to record the path which find from root to the specific nodes.</li>
<li>Compare elements from two lists and get the last common elements.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</div><div class="line">		<span class="keyword">if</span>(findNode(root.left,p)) &#123;</div><div class="line">			<span class="keyword">if</span>(findNode(root.left,q)) &#123;</div><div class="line">				<span class="keyword">return</span> getLastCommonParentRec(root.left,p,q);</div><div class="line">			&#125;<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> root;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span>(findNode(root.right,q)) &#123;</div><div class="line">				<span class="keyword">return</span> getLastCommonParentRec(root.right,p,q);</div><div class="line">			&#125;<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> root;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	boolean findNode(TreeNode root, TreeNode node) &#123;</div><div class="line">		<span class="keyword">if</span>(root==<span class="literal">null</span> || node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(root==node) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		</div><div class="line">		boolean found = findNode(root.left,node);</div><div class="line">		<span class="keyword">if</span>(!found) &#123;</div><div class="line">			found = findNode(root.right,node);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> found;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</div><div class="line">		<span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">		<span class="keyword">if</span>(root==p || root==q) <span class="keyword">return</span> root;</div><div class="line">		TreeNode commonLeft = getLastCommonParentRec(root.left,p,q);</div><div class="line">		TreeNode commonRight = getLastCommonParentRec(root.right,p,q);</div><div class="line">		<span class="keyword">if</span>(commonLeft!=<span class="literal">null</span> &amp;&amp; commonRight!=<span class="literal">null</span>) <span class="keyword">return</span> root;</div><div class="line">		<span class="keyword">if</span>(commonLeft!=<span class="literal">null</span>) <span class="keyword">return</span> commonLeft;</div><div class="line">		<span class="keyword">return</span> commonRight;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</div><div class="line">		ArrayList&lt;TreeNode&gt; list1 = new ArrayList&lt;&gt;();</div><div class="line">		ArrayList&lt;TreeNode&gt; list2 = new ArrayList&lt;&gt;();</div><div class="line">		boolean found1 = findPath(root,p,list1);</div><div class="line">		boolean found2 = findPath(root,q,list2);</div><div class="line">		<span class="keyword">if</span>(!found1 || !found2) <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">	</div><div class="line">		TreeNode result = <span class="literal">null</span>;</div><div class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;Math.min(list1.size(),list2.size());i++) &#123;</div><div class="line">			<span class="keyword">if</span>(list1.<span class="keyword">get</span>(i)==list2.<span class="keyword">get</span>(i))&#123;</div><div class="line">				result = list1.<span class="keyword">get</span>(i);</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	boolean findPath(TreeNode root, TreeNode node, ArrayList&lt;TreeNode&gt; list) &#123;</div><div class="line">		<span class="keyword">if</span>(root==<span class="literal">null</span> || node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		list.add(root);</div><div class="line">		<span class="keyword">if</span>(root == node) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		boolean found = findPath(root.left,node,list);</div><div class="line">		<span class="keyword">if</span>(!found) &#123;</div><div class="line">			found = findPath(root.right,node,list);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(!found) list.remove(root);</div><div class="line">		<span class="keyword">return</span> found;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link href="http://xinli90.com/2016/08/25/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
    <id>http://xinli90.com/2016/08/25/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</id>
    <published>2016-08-25T21:43:58.000Z</published>
    <updated>2016-08-28T19:58:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="external">Leetcode-Construct Binary Tree from Preorder and Inorder Traversal </a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution-Iterative-solution"><a href="#Solution-Iterative-solution" class="headerlink" title="Solution: Iterative solution."></a>Solution: Iterative solution.</h4><ol>
<li>PreOrder: root is the first element in the array and use this element to divide inorder array. </li>
<li>InOrder: the left array of the root is left subtree and the right array of the root is right subtree.We can get the size of left subtree and right subtree and use for the preorder array. Use this size to divide preorder array and build tree.</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span>(<span class="params"><span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> buildTree(preorder,<span class="number">0</span>,preorder.length<span class="number">-1</span>,inorder,<span class="number">0</span>,inorder.length<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">	<span class="function">TreeNode <span class="title">buildTree</span>(<span class="params"><span class="keyword">int</span>[]preorder,<span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[]inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd</span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span>(preStart &gt; preEnd) <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">		<span class="keyword">int</span> rootVal = preorder[preStart];</div><div class="line">		<span class="keyword">int</span> inRoot=<span class="number">-1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=inStart,j=inEnd; i&lt;=j; i++,j--) &#123;</div><div class="line">			<span class="keyword">if</span>(inorder[i] == rootVal) &#123;</div><div class="line">				inRoot = i;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span>(<span class="params">inorder[j] == rootVal</span>)</span>&#123;</div><div class="line">				inRoot = j;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125; </div><div class="line">		TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</div><div class="line">		root.left = buildTree(preorder,preStart+<span class="number">1</span>,preStart+(inRoot-inStart), inorder,inStart,inRoot<span class="number">-1</span>);</div><div class="line">		root.right = buildTree(preorder,preEnd-(inEnd-inRoot)+<span class="number">1</span>,preEnd,inorder,inRoot+<span class="number">1</span>,inEnd);</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&quot; target=&quot;_bl
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Balanced Binary Tree</title>
    <link href="http://xinli90.com/2016/08/24/Balanced-Binary-Tree/"/>
    <id>http://xinli90.com/2016/08/24/Balanced-Binary-Tree/</id>
    <published>2016-08-24T21:31:16.000Z</published>
    <updated>2016-08-28T03:58:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="external">Leetcode-Balanced Binary Tree</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1-Recursive-solution"><a href="#Solution1-Recursive-solution" class="headerlink" title="Solution1: Recursive solution."></a>Solution1: Recursive solution.</h4><p>Time complexity is O(nlogn).     </p>
<ol>
<li>if tree is null, return true;</li>
<li>if the difference of left subtree and right subtree is greater than 1, return false;</li>
<li>recursively compare left subtree and right subtree loop 1 and 2.</li>
</ol>
<h4 id="Solution2-Recursive-solution"><a href="#Solution2-Recursive-solution" class="headerlink" title="Solution2: Recursive solution."></a>Solution2: Recursive solution.</h4><p>Time complexity is O(n)</p>
<ol>
<li>Get the depth of left subtree and right subtree from bottom to the top.</li>
<li>Once the difference of two depth is greater than 1, it will always return -1 and there is no need to compare any more.  If not, return its depth for the father node.   </li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> boolean isBalanced(TreeNode root) &#123;</div><div class="line">		<span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		<span class="keyword">if</span>(Math.abs(getDepth(root.left)-getDepth(root.right))&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		<span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	int getDepth(TreeNode node) &#123;</div><div class="line">		<span class="keyword">if</span>(node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">return</span> Math.max(getDepth(node.left),getDepth(node.right))+<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> boolean isBalanced(TreeNode root) &#123;			<span class="keyword">if</span>(getDepth(root)==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	int getDepth(TreeNode node) &#123;</div><div class="line">		<span class="keyword">if</span>(node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		</div><div class="line">		int leftDepth = getDepth(node.left);</div><div class="line">		<span class="keyword">if</span>(leftDepth==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		</div><div class="line">		int rightDepth = getDepth(node.right);</div><div class="line">		<span class="keyword">if</span>(rightDepth==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		</div><div class="line">		int diff = Math.abs(leftDepth-rightDepth);</div><div class="line">		<span class="keyword">if</span>(diff&gt;<span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> Math.max(leftDepth,rightDepth) + <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/balanced-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetcode-Balanced
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Same Tree</title>
    <link href="http://xinli90.com/2016/08/24/Same-Tree/"/>
    <id>http://xinli90.com/2016/08/24/Same-Tree/</id>
    <published>2016-08-24T17:50:50.000Z</published>
    <updated>2016-08-28T20:28:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="external">Leetcode-Same Tree</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1-Recursive-solution"><a href="#Solution1-Recursive-solution" class="headerlink" title="Solution1: Recursive solution."></a>Solution1: Recursive solution.</h4><ol>
<li>if two nodes are null, return true;</li>
<li>if the value of two nodes are equivalent, recursively compare their left and right subtree.</li>
<li>else return false.</li>
</ol>
<h4 id="Solution2-Iterative-solution"><a href="#Solution2-Iterative-solution" class="headerlink" title="Solution2: Iterative solution."></a>Solution2: Iterative solution.</h4><ol>
<li>Traverse two trees and compare each nodes.</li>
<li>Use Pre-Order traversal.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> boolean isSameTree(TreeNode p, TreeNode q) &#123;</div><div class="line">		<span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		<span class="keyword">if</span>(p==<span class="literal">null</span> || q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		<span class="keyword">if</span>(p.<span class="keyword">val</span>!=q.<span class="keyword">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		<span class="keyword">if</span>(p.<span class="keyword">val</span>==q.<span class="keyword">val</span>) <span class="keyword">return</span> isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> boolean isSameTree(TreeNode p, TreeNode q) &#123;		<span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		<span class="keyword">if</span>(p==<span class="literal">null</span> || q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;();</div><div class="line">		Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;();</div><div class="line">		s1.push(p);</div><div class="line">		s2.push(q);</div><div class="line">		<span class="keyword">while</span>(!s1.isEmpty() &amp;&amp; !s2.isEmpty()) &#123;</div><div class="line">			TreeNode node1 = s1.pop();</div><div class="line">			TreeNode node2 = s2.pop();</div><div class="line">			<span class="keyword">if</span>(node1==<span class="literal">null</span> &amp;&amp; node2==<span class="literal">null</span>) <span class="keyword">continue</span>;</div><div class="line">			<span class="keyword">if</span>(node1!=<span class="literal">null</span> &amp;&amp; node2!=<span class="literal">null</span> &amp;&amp; node1.<span class="keyword">val</span>==node2.<span class="keyword">val</span>) &#123;</div><div class="line">				s1.push(node1.left);</div><div class="line">				s1.push(node1.right);</div><div class="line">				s2.push(node2.left);</div><div class="line">				s2.push(node2.right);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">			&#125;	</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/same-tree/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetcode-Same Tree&lt;/a&gt;.&lt;/p&gt;

    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Flatten Binary Tree to Linked List</title>
    <link href="http://xinli90.com/2016/08/23/Flatten-Binary-Tree-to-Linked-List/"/>
    <id>http://xinli90.com/2016/08/23/Flatten-Binary-Tree-to-Linked-List/</id>
    <published>2016-08-23T19:53:28.000Z</published>
    <updated>2016-08-28T20:09:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="external">Leetcode-Binary Tree Level Order Traversal</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    <span class="number">1</span></div><div class="line">   / \</div><div class="line">  <span class="number">2</span>   <span class="number">5</span></div><div class="line"> / \   \</div><div class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></div></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"> \</div><div class="line">  <span class="number">2</span></div><div class="line">   \</div><div class="line">    <span class="number">3</span></div><div class="line">     \</div><div class="line">      <span class="number">4</span></div><div class="line">       \</div><div class="line">        <span class="number">5</span></div><div class="line">         \</div><div class="line">          <span class="number">6</span></div></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1-Recursive-solution-Like-post-order-solution"><a href="#Solution1-Recursive-solution-Like-post-order-solution" class="headerlink" title="Solution1: Recursive solution. Like post-order solution."></a>Solution1: Recursive solution. Like post-order solution.</h4><ol>
<li>if tree is null, return.</li>
<li>if tree is not null, Recursively traverse left subtree and then right subtree, change the left subtree to the right and the original right subtree as the most right node.</li>
</ol>
<h4 id="Solution2-Iterative-solution"><a href="#Solution2-Iterative-solution" class="headerlink" title="Solution2: Iterative solution."></a>Solution2: Iterative solution.</h4><ol>
<li>Each time, make the right subtree of root to be the right subtree of most right node of left child node of root.</li>
<li>Then make the left subtree as the right subtree of the root, move to the next right node, loop 1 and 2.</li>
</ol>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> a binary tree node.</div><div class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> TreeNode &#123;</div><div class="line"> *     <span class="built_in">int</span> val;</div><div class="line"> *     TreeNode <span class="built_in">left</span>;</div><div class="line"> *     TreeNode <span class="built_in">right</span>;</div><div class="line"> *     TreeNode(<span class="built_in">int</span> x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution1 &#123;</div><div class="line">	<span class="keyword">public</span> void flatten(TreeNode root) &#123;</div><div class="line">		<span class="keyword">if</span>(root == <span class="literal">null</span>) return;</div><div class="line">		</div><div class="line">		flatten(root.<span class="built_in">left</span>);</div><div class="line">		flatten(root.<span class="built_in">right</span>);</div><div class="line">		</div><div class="line">		TreeNode <span class="built_in">right</span> = root.<span class="built_in">right</span>;</div><div class="line">		root.<span class="built_in">right</span> = root.<span class="built_in">left</span>;</div><div class="line">		root.<span class="built_in">left</span> = <span class="literal">null</span>;</div><div class="line">		TreeNode cur = root;</div><div class="line">		<span class="keyword">while</span>(cur.<span class="built_in">right</span>!=<span class="literal">null</span>) cur = cur.<span class="built_in">right</span>;</div><div class="line">		cur.<span class="built_in">right</span> = <span class="built_in">right</span>;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution2 &#123;</div><div class="line">	<span class="keyword">public</span> void flatten(TreeNode root) &#123;</div><div class="line">		<span class="keyword">if</span>(root == <span class="literal">null</span>) return;</div><div class="line">		<span class="keyword">while</span>(root!=<span class="literal">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span>(root.<span class="built_in">left</span>==<span class="literal">null</span>)&#123;</div><div class="line">				root = root.<span class="built_in">right</span>;</div><div class="line">				continue;</div><div class="line">			&#125;</div><div class="line">			TreeNode <span class="built_in">left</span> = root.<span class="built_in">left</span>;</div><div class="line">			<span class="keyword">while</span>(<span class="built_in">left</span>.<span class="built_in">right</span>!=<span class="literal">null</span>) &#123;</div><div class="line">				<span class="built_in">left</span> = <span class="built_in">left</span>.<span class="built_in">right</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">left</span>.<span class="built_in">right</span> = root.<span class="built_in">right</span>;</div><div class="line">			root.<span class="built_in">right</span> = root.<span class="built_in">left</span>;</div><div class="line">			root.<span class="built_in">left</span> = <span class="literal">null</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/binary-tree-level-order-traversal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leet
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Level Order Traversal</title>
    <link href="http://xinli90.com/2016/08/23/Binary-Tree-Level-Order-Traversal/"/>
    <id>http://xinli90.com/2016/08/23/Binary-Tree-Level-Order-Traversal/</id>
    <published>2016-08-23T18:29:04.000Z</published>
    <updated>2016-08-28T03:22:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="external">Leetcode-Binary Tree Level Order Traversal</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    <span class="number">3</span></div><div class="line">   / \</div><div class="line">  <span class="number">9</span>   <span class="number">20</span></div><div class="line"> / \   </div><div class="line"><span class="number">15</span>  <span class="number">7</span></div></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [<span class="number">3</span>],</div><div class="line">  [<span class="number">9</span>,<span class="number">20</span>],</div><div class="line">  [<span class="number">15</span>,<span class="number">7</span>]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis:"></a>Analysis:</h3><h4 id="Solution1-Recursive-solution"><a href="#Solution1-Recursive-solution" class="headerlink" title="Solution1: Recursive solution."></a>Solution1: Recursive solution.</h4><ol>
<li>if the tree is null, return.      </li>
<li>if the tree is not null, compare if the size of lists equals to the level. If yes, directly add current node into lists.get(level). If no, create a new list into lists.</li>
<li>Recursively traverse left subtree and right subtree and the level+1.</li>
</ol>
<h4 id="Solution2-Iterative-solution"><a href="#Solution2-Iterative-solution" class="headerlink" title="Solution2: Iterative solution."></a>Solution2: Iterative solution.</h4><ol>
<li>Use BFS.</li>
<li>For each loop, we add them together into a new List.</li>
</ol>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> class Solution1 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">		<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; lists = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">		helper(lists, root,<span class="number">0</span>);</div><div class="line">		<span class="keyword">return</span> lists;</div><div class="line">	&#125;</div><div class="line">	<span class="literal">void</span> helper(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; lists, TreeNode node, int level) &#123;</div><div class="line">		<span class="keyword">if</span>(node == <span class="built_in">null</span>) <span class="keyword">return</span>;</div><div class="line">		<span class="comment">//add a new list to the new level of nodes</span></div><div class="line">		<span class="keyword">if</span>(lists.size() == level) lists.add(<span class="literal">new</span> ArrayList&lt;<span class="built_in">Integer</span>&gt;());</div><div class="line">		<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; temp = lists.get(level);</div><div class="line">		temp.add(node.val);</div><div class="line">		helper(lists, node.left,level+<span class="number">1</span>);</div><div class="line">		helper(lists, node.right,level+<span class="number">1</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> class Solution2 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">		<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; lists = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> lists;</div><div class="line">		<span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</div><div class="line">		<span class="built_in">queue</span>.add(root);</div><div class="line">		<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</div><div class="line">			int size = <span class="built_in">queue</span>.size();</div><div class="line">			<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">			for(int i=<span class="number">0</span>;i&lt;size;i++) &#123;</div><div class="line">				TreeNode node = <span class="built_in">queue</span>.poll();</div><div class="line">				<span class="built_in">list</span>.add(node.val);</div><div class="line">				<span class="keyword">if</span>(node.left!=<span class="built_in">null</span>) <span class="built_in">queue</span>.add(node.left);</div><div class="line">				<span class="keyword">if</span>(node.right!=<span class="built_in">null</span>) <span class="built_in">queue</span>.add(node.right);</div><div class="line">			&#125;</div><div class="line">			lists.add(<span class="built_in">list</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> lists;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/binary-tree-level-order-traversal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leet
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Postorder Traversal</title>
    <link href="http://xinli90.com/2016/08/23/Binary-Tree-Postorder-Traversal/"/>
    <id>http://xinli90.com/2016/08/23/Binary-Tree-Postorder-Traversal/</id>
    <published>2016-08-23T18:09:59.000Z</published>
    <updated>2016-08-28T03:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="external">Leetcode-Binary Tree Postorder Traversal</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"> \</div><div class="line">  <span class="number">2</span></div><div class="line"> /</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>return <code>[3,2,1]</code>.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1-Recursive-solution"><a href="#Solution1-Recursive-solution" class="headerlink" title="Solution1: Recursive solution."></a>Solution1: Recursive solution.</h4><ol>
<li>if the tree is null, return.      </li>
<li>if the tree is not null, traverse left subtree, traverse right subtree, visit root and add the value of root into list.</li>
</ol>
<h4 id="Solution2-Iterative-solution"><a href="#Solution2-Iterative-solution" class="headerlink" title="Solution2: Iterative solution."></a>Solution2: Iterative solution.</h4><ol>
<li>Keep two stacks</li>
<li>Use the way similar to Preorder traversal, preorder is：<code>self, left, right</code>, change its order to <code>self, right, left</code>, then converse to <code>left, right, self</code>    </li>
</ol>
<h4 id="Solution3-Iterative-solution"><a href="#Solution3-Iterative-solution" class="headerlink" title="Solution3: Iterative solution."></a>Solution3: Iterative solution.</h4><ol>
<li>Only one stack. similar to preorder traversal(iterative solution), push root into stack first, then push right subnode and then left subnode.</li>
<li>There are two situations we need pop node from stack to the list. One is the left subnode and right subnode of the current node is null.  Another is the left subtree and right subtree have been visited.</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree <span class="keyword">node</span>.</div><div class="line"> <span class="title">* public</span> class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"> </div><div class="line"> </div><div class="line">public class Solution1 &#123;</div><div class="line">	public List<span class="tag">&lt;Integer&gt;</span> postorderTraversal(TreeNode root) &#123;</div><div class="line">		List<span class="tag">&lt;Integer&gt;</span> list = new ArrayList<span class="tag">&lt;&gt;</span>();</div><div class="line">		helper(list, root);</div><div class="line">		return list;</div><div class="line">	&#125;</div><div class="line">	void helper(List<span class="tag">&lt;Integer&gt;</span> list, TreeNode <span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">		if(<span class="keyword">node</span> <span class="title">== null</span>) return;</div><div class="line">		helper(list, <span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">		helper(list, <span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">		list.add(<span class="keyword">node</span>.<span class="title">val</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Solution2 &#123;</div><div class="line">	//Two stack</div><div class="line">	public List<span class="tag">&lt;Integer&gt;</span> postorderTraversal(TreeNode root) &#123;</div><div class="line">		List<span class="tag">&lt;Integer&gt;</span> list = new ArrayList<span class="tag">&lt;&gt;</span>();</div><div class="line">		if(root == null) return list;</div><div class="line">		Stack<span class="tag">&lt;TreeNode&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</div><div class="line">		Stack<span class="tag">&lt;TreeNode&gt;</span> reverseStack = new Stack<span class="tag">&lt;&gt;</span>();</div><div class="line">		stack.push(root);</div><div class="line">		while(!stack.isEmpty()) &#123;</div><div class="line">			TreeNode <span class="keyword">node</span> <span class="title">= stack</span>.pop();</div><div class="line">			reverseStack.push(<span class="keyword">node</span><span class="title">);</span></div><div class="line">			if(<span class="keyword">node</span>.<span class="title">left</span>!=null) stack.push(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">			if(<span class="keyword">node</span>.<span class="title">right</span>!=null) stack.push(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">		&#125;</div><div class="line">		while(!reverseStack.isEmpty()) &#123;</div><div class="line">			list.add(reverseStack.pop());</div><div class="line">		&#125;</div><div class="line">		return list;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Solution3 &#123;</div><div class="line">	public List<span class="tag">&lt;Integer&gt;</span> postorderTraversal(TreeNode root) &#123;</div><div class="line">		List<span class="tag">&lt;Integer&gt;</span> list = new ArrayList<span class="tag">&lt;&gt;</span>();</div><div class="line">		if(root == null) return list;</div><div class="line">		Stack<span class="tag">&lt;TreeNode&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</div><div class="line">		stack.push(root);</div><div class="line">		TreeNode prev = null;</div><div class="line">		while(!stack.isEmpty()) &#123;</div><div class="line">			TreeNode <span class="keyword">node</span> <span class="title">= stack</span>.peek();</div><div class="line">			</div><div class="line">			//<span class="keyword">node</span>.<span class="title">left</span>==null &amp;&amp; <span class="keyword">node</span>.<span class="title">right</span>==null means <span class="keyword">node</span> <span class="title">is</span> leave</div><div class="line">			//prev!=null &amp;&amp; <span class="attr">prev=</span>=<span class="keyword">node</span>.<span class="title">left</span> means have already traversed left subtree, the right subtree is null			//prev!=null &amp;&amp; <span class="attr">prev=</span>=<span class="keyword">node</span>.<span class="title">right</span> means have already traversed right subtree</div><div class="line">			//prev!=<span class="keyword">node</span>.<span class="title">left</span>&amp;&amp;prev!=<span class="keyword">node</span>.<span class="title">right</span> means have poped from stack several times <span class="keyword">and</span> get to the another side of tree.</div><div class="line">			</div><div class="line">			if((<span class="keyword">node</span>.<span class="title">left</span>==null &amp;&amp; <span class="keyword">node</span>.<span class="title">right</span>==null)||(prev!=null &amp;&amp; (prev == <span class="keyword">node</span>.<span class="title">left</span> || <span class="attr">prev=</span>=<span class="keyword">node</span>.<span class="title">right</span>))) &#123;</div><div class="line">				<span class="keyword">node</span> <span class="title">= stack</span>.pop();</div><div class="line">				list.add(<span class="keyword">node</span>.<span class="title">val</span>);</div><div class="line">				prev = <span class="keyword">node</span><span class="title">;</span></div><div class="line">			&#125;else &#123;</div><div class="line">				if(<span class="keyword">node</span>.<span class="title">right</span>!=null) stack.push(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">				if(<span class="keyword">node</span>.<span class="title">left</span>!=null) stack.push(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">			&#125;		</div><div class="line">		&#125;</div><div class="line">		return list;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/binary-tree-postorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetco
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Inorder Traversal</title>
    <link href="http://xinli90.com/2016/08/23/Binary-Tree-Inorder-Traversal/"/>
    <id>http://xinli90.com/2016/08/23/Binary-Tree-Inorder-Traversal/</id>
    <published>2016-08-23T17:42:55.000Z</published>
    <updated>2016-08-28T03:58:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="external">Leetcode-Binary Tree Inorder Traversal</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"> \</div><div class="line">  <span class="number">2</span></div><div class="line"> /</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>return <code>[1,3,2]</code>.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1-Recursive-solution"><a href="#Solution1-Recursive-solution" class="headerlink" title="Solution1: Recursive solution."></a>Solution1: Recursive solution.</h4><ol>
<li>if the tree is null, return.      </li>
<li>if the tree is not null, traverse left subtree, visit root and add the value of root into list, and then right subtree.</li>
</ol>
<h4 id="Solution2-Iterative-solution"><a href="#Solution2-Iterative-solution" class="headerlink" title="Solution2: Iterative solution."></a>Solution2: Iterative solution.</h4><ol>
<li>Utilize Stack, traverse left subtree of the root to the left most node and push them into stack.      </li>
<li>If left subtree is null, pop() one node from stack and record its value into list. Visit the right subtree of this node once, and then repeat 1 and 2 operation.          </li>
<li>Notice: here is a tricky point. Since traverse left subtree of the root, there is no need to traverse left subtree again for the node which pop from the stack.  Therefore, we need have two nodes. One assigns to the node pop from stack. One assigns to the new node which we find when we traverse right subtree of someone. Traverse left subtree only for the second node.        </li>
</ol>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> class Solution1 &#123;</div><div class="line">	<span class="comment">//Solution1: add helper() method</span></div><div class="line">	<span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;</div><div class="line">		<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">		helper(<span class="built_in">list</span>, root);</div><div class="line">		<span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="literal">void</span> helper(<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span>, TreeNode node) &#123;</div><div class="line">		<span class="keyword">if</span>(node == <span class="built_in">null</span>) <span class="keyword">return</span>;</div><div class="line">		helper(<span class="built_in">list</span>, node.left);</div><div class="line">		<span class="built_in">list</span>.add(node.val);</div><div class="line">		helper(<span class="built_in">list</span>,node.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> class Solution2 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;</div><div class="line">		<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">		<span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</div><div class="line">		<span class="built_in">stack</span>.push(root);</div><div class="line">		TreeNode node = root;</div><div class="line">		<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;	</div><div class="line">			<span class="keyword">while</span>(node.left!=<span class="built_in">null</span>) &#123;</div><div class="line">				<span class="built_in">stack</span>.push(node.left);</div><div class="line">				node = node.left;</div><div class="line">			&#125;</div><div class="line">			TreeNode addNode = <span class="built_in">stack</span>.pop();</div><div class="line">			<span class="built_in">list</span>.add(addNode.val);</div><div class="line">			<span class="keyword">if</span>(addNode.right!=<span class="built_in">null</span>) &#123;</div><div class="line">				<span class="built_in">stack</span>.push(addNode.right);</div><div class="line">				node = addNode.right;</div><div class="line">			&#125;	</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/binary-tree-inorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetcode
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Preorder Traversal</title>
    <link href="http://xinli90.com/2016/08/23/Binary-Tree-Preorder-Traversal/"/>
    <id>http://xinli90.com/2016/08/23/Binary-Tree-Preorder-Traversal/</id>
    <published>2016-08-23T17:26:02.000Z</published>
    <updated>2016-08-28T04:00:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="external">Leetcode-Binary Tree Preorder Traversal</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"> \</div><div class="line">  <span class="number">2</span></div><div class="line"> /</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>return <code>[1,2,3]</code>.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1-Recursive-solution"><a href="#Solution1-Recursive-solution" class="headerlink" title="Solution1: Recursive solution."></a>Solution1: Recursive solution.</h4><ol>
<li>if the tree is null, return.      </li>
<li>if the tree is not null, visit root and add the value of root into list. Traverse left subtree and then right subtree.</li>
</ol>
<h4 id="Solution2-Recursive-solution"><a href="#Solution2-Recursive-solution" class="headerlink" title="Solution2: Recursive solution."></a>Solution2: Recursive solution.</h4><p>The similar way with solution1, but without helper() method.     </p>
<h4 id="Solution3-Iterative-solution"><a href="#Solution3-Iterative-solution" class="headerlink" title="Solution3: Iterative solution."></a>Solution3: Iterative solution.</h4><ol>
<li>Utilize Stack, Each time we use List to store the output node from stack.    </li>
<li>Traverse the output node from right to left and push into stack.    </li>
<li>Loop 1 and 2 operation.    </li>
</ol>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> class Solution1 &#123;</div><div class="line">	<span class="comment">//Solution1: add helper() method</span></div><div class="line">	<span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; preorderTraversalRec(TreeNode root) &#123;</div><div class="line">		<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">		helper(<span class="built_in">list</span>,root);</div><div class="line">		<span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="literal">void</span> helper(<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span>, TreeNode node) &#123;</div><div class="line">		<span class="keyword">if</span>(node==<span class="built_in">null</span>) <span class="keyword">return</span>;</div><div class="line">		<span class="built_in">list</span>.add(node.val);</div><div class="line">		helper(<span class="built_in">list</span>,node.left);</div><div class="line">		helper(<span class="built_in">list</span>,node.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> class Solution2 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; preorderTraversalRec(TreeNode root) &#123;</div><div class="line">		<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">		<span class="built_in">list</span>.add(root.val);</div><div class="line">		<span class="built_in">list</span>.addAll(preorderTraversalRec(root.left));</div><div class="line">		<span class="built_in">list</span>.addAll(preorderTraversalRec(root.right));</div><div class="line">		<span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> class Solution3 &#123;</div><div class="line">		<span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; preorderTraversal(TreeNode root) &#123;</div><div class="line">		<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">		<span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</div><div class="line">		<span class="built_in">stack</span>.push(root);</div><div class="line">		<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;</div><div class="line">			TreeNode node = <span class="built_in">stack</span>.pop();</div><div class="line">			<span class="built_in">list</span>.add(node.val);</div><div class="line">			<span class="keyword">if</span>(node.right!=<span class="built_in">null</span>)<span class="built_in">stack</span>.push(node.right);</div><div class="line">			<span class="keyword">if</span>(node.left!=<span class="built_in">null</span>)<span class="built_in">stack</span>.push(node.left);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/binary-tree-preorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetcod
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Depth of Binary Tree</title>
    <link href="http://xinli90.com/2016/08/23/Maximum-Depth-of-Binary-Tree/"/>
    <id>http://xinli90.com/2016/08/23/Maximum-Depth-of-Binary-Tree/</id>
    <published>2016-08-23T16:44:52.000Z</published>
    <updated>2016-08-28T20:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="external">Leetcode-Maximum Depth of Binary Tree</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1-Recursive-solution"><a href="#Solution1-Recursive-solution" class="headerlink" title="Solution1: Recursive solution."></a>Solution1: Recursive solution.</h4><ol>
<li>if the tree is null, the depth is 0;      </li>
<li>if the tree is null, the depth = max(depth of left tree，depth of right tree) + 1       </li>
</ol>
<h4 id="Solution2-Iterative-solution"><a href="#Solution2-Iterative-solution" class="headerlink" title="Solution2: Iterative solution."></a>Solution2: Iterative solution.</h4><p>Utilize BFS, count the levels. It’s the same as the the number of loops.      </p>
<h4 id="Solution3-Iterative-solution"><a href="#Solution3-Iterative-solution" class="headerlink" title="Solution3: Iterative solution."></a>Solution3: Iterative solution.</h4><p>Utilize DFS, record the depth of each path and maintain the maximum one until traversal all paths.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution1 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> maxDepth(TreeNode root) &#123;</div><div class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution2 &#123;</div><div class="line">	<span class="comment">//Traverse tree use BFS</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> getNodeNum(TreeNode root) &#123;</div><div class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">		<span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</div><div class="line">		queue.add(root);</div><div class="line">		<span class="keyword">while</span>(!queue.isEmpty()) &#123;</div><div class="line">			<span class="keyword">int</span> <span class="keyword">size</span> = queue.<span class="keyword">size</span>();</div><div class="line">			<span class="keyword">count</span> += <span class="keyword">size</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">size</span>;i++) &#123;</div><div class="line">				TreeNode node = queue.poll();</div><div class="line">				<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</div><div class="line">				<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">count</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetcode-
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Day10 Algorithm about Itetation and Recursion</title>
    <link href="http://xinli90.com/2016/08/22/Day10-Algorithm-about-Itetation-and-Recursion/"/>
    <id>http://xinli90.com/2016/08/22/Day10-Algorithm-about-Itetation-and-Recursion/</id>
    <published>2016-08-22T18:05:19.000Z</published>
    <updated>2016-08-22T18:05:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Day9 Algorithm about Binary Tree</title>
    <link href="http://xinli90.com/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/"/>
    <id>http://xinli90.com/2016/08/22/Day9-Algorithm-about-Binary-Search-Tree/</id>
    <published>2016-08-22T17:53:19.000Z</published>
    <updated>2016-08-28T20:08:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是关于二叉树Binary Tree算法的分析和总结。</p>
<h2 id="攻略模板"><a href="#攻略模板" class="headerlink" title="攻略模板"></a>攻略模板</h2><ul>
<li>回忆算法特性</li>
<li>实现算法功能</li>
<li>实战训练使用该算法</li>
<li>总结该算法特点，并总结算法题</li>
</ul>
<h2 id="自己回忆"><a href="#自己回忆" class="headerlink" title="自己回忆"></a>自己回忆</h2><ul>
<li>一般二叉树的查找可以使用DFS 和 BFS</li>
<li>平衡二叉树可以使用二分法，时间复杂度为O(logn)</li>
<li>二叉树的遍历有先序遍历，中序遍历 和 后序遍历</li>
<li>Binary Tree and Binary Search Tree: Each node of BT and BST only allowed two children nodes. What’s more, in BST, left &lt; current &lt; right.</li>
</ul>
<h2 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h2><p>在这里我们总结出经典15道二叉树题目： </p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//Definition for a binary tree node.</div><div class="line">Class TreeNode&#123;</div><div class="line">	<span class="built_in">int</span> val;</div><div class="line">	TreeNode <span class="built_in">left</span>;</div><div class="line">	TreeNode <span class="built_in">right</span>;</div><div class="line">	TreeNode(<span class="built_in">int</span> x) &#123;</div><div class="line">		val = x;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">```          </div><div class="line"></div><div class="line"><span class="number">1</span>.求二叉树中的节点个数<span class="symbol">:</span> getNodeNumRec（递归），getNodeNum（迭代） </div><div class="line"></div><div class="line">递归解法：<span class="built_in">Time</span> O(<span class="built_in">n</span>)      </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，节点个数为<span class="number">0</span>       </div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + <span class="number">1</span>  </div><div class="line"></div><div class="line">迭代解法：<span class="built_in">Time</span> O(<span class="built_in">n</span>)     </div><div class="line">使用DFS 或者 BFS 遍历所有节点，统计节点个数</div></pre></td></tr></table></figure>
<p>public int getNodeNumRec(TreeNode root) {<br>    if(root == null) return 0;<br>    return getNodeNumRec(root.left)+getNodeNumRec(root.right)+1;<br>}</p>
<p>//Traverse tree use BFS<br>public int getNodeNum(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new ArrayDeque&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        count += size;<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>    return count;<br>}</treenode></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     </div><div class="line"><span class="number">2</span>.求二叉树的深度<span class="symbol">:</span> getDepthRec（递归），getDepth(迭代)</div><div class="line">LeetCode - <span class="number">104</span>.Maximum Depth of Binary Tree</div><div class="line">递归解法<span class="symbol">:</span>  <span class="built_in">Time</span> O(<span class="built_in">n</span>)       </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，深度为<span class="number">0</span></div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，二叉树深度 = <span class="built_in">max</span>(左子树深度，右子树的深度) + <span class="number">1</span></div><div class="line"></div><div class="line">迭代解法： <span class="built_in">Time</span> O(<span class="built_in">n</span>)    </div><div class="line">(<span class="number">1</span>)解法一：使用BFS,统计层数 即 执行循环的次数</div><div class="line">(<span class="number">2</span>)解法二：使用DFS,每次一条路径到底，比较深度，把所有树遍历一遍，找出最大长度</div></pre></td></tr></table></figure>
<p>public int getDepthRec(TreeNode root) {<br>    if(root==null) retrun 0;<br>    return Math.max(getDepthRec(root.left),getDepthRec(root.right))+1;<br>}</p>
<p>//Traverse tree use BFS<br>public int getNodeNum(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        count++;<br>        for(int i=0;i<size;i++) {="" treenode="" node="queue.poll();" if(node.left!="null)" queue.add(node.left);="" if(node.right!="null)" queue.add(node.right);="" }="" return="" count;="" <figure="" class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">3</span>.前序遍历，中序遍历，后序遍历: preorderTraversalRec, preorderTraversal, inorderTraversalRec, postorderTraversalRec (&lt;http<span class="variable">s:</span>//<span class="keyword">en</span>.wikipedia.org/wiki/Tree_traversal#Pre-order_2&gt;) </div><div class="line">       </div><div class="line">LeetCode - <span class="number">104</span>.Binary Tree Preorder Traversal     </div><div class="line">Pre-Order递归解法:  Time O(n)       </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回      </div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，访问根节点,<span class="keyword">list</span>.<span class="built_in">add</span>(root.val), 前序遍历左子树，前序遍历右子树</div></pre></td></tr></table></size;i++)></treenode></p>
<p>//Solution1: add helper() method<br>public List<integer> preorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list,root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node==null) return;<br>    list.add(node.val);<br>    helper(list,node.left);<br>    helper(list,node.right);<br>}</integer></p>
<p>//Solution2<br>public List<integer> preorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    list.add(root.val);<br>    list.addAll(preorderTraversalRec(root.left));<br>    list.addAll(preorderTraversalRec(root.right));<br>    return list;<br>}</integer></integer></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pre-<span class="keyword">Order</span>迭代解法:  Time <span class="keyword">O</span>(n), <span class="keyword">Space</span> <span class="keyword">O</span>(n)       </div><div class="line">使用<span class="keyword">Stack</span>, 用<span class="keyword">List</span>存储输出的节点，每次从右向左遍历子节点, 存入<span class="keyword">Stack</span>中</div></pre></td></tr></table></figure>
<p>public List<integer> preorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        list.add(node.val);<br>        if(node.right!=null)stack.push(node.right);<br>        if(node.left!=null)stack.push(node.left);<br>    }<br>    return list;<br>}</treenode></integer></integer></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">LeetCode - 94<span class="selector-class">.Binary</span> <span class="selector-tag">Tree</span> <span class="selector-tag">Inorder</span> <span class="selector-tag">Traversal</span>   </div><div class="line"><span class="selector-tag">In-Order</span>递归解法:  <span class="selector-tag">Time</span> <span class="selector-tag">O</span>(n)       </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回       </div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，中序遍历左子树，访问根节点,<span class="selector-tag">list</span><span class="selector-class">.add</span>(root.val), 中序遍历右子树</div></pre></td></tr></table></figure>
<p>public List<integer> inorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list, root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node == null) return;<br>    helper(list, node.left);<br>    list.add(node.val);<br>    helper(list,node.right);<br>}</integer></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">In</span>-<span class="keyword">Order</span>迭代解法:  Time O(<span class="keyword">n</span>)       </div><div class="line">(1) 使用<span class="keyword">Stack</span>, 先把每个需要存入的节点遍历所有左子节点，并全部存入      </div><div class="line">(2) 如果左子树为空，则从<span class="keyword">stack</span>中输出一个节点，用<span class="keyword">list</span>依次记录所有输出节点，以此节点向右访问一次右节点，然后重复（1）操作。</div><div class="line">(3) 特别注意：这里有个tricky的地方，就是一开始是从root节点直接向左遍历，但当我从<span class="keyword">stack</span>中输出的节点就不需要再向左遍历，所以需要创建两个新的节点，一个代表从<span class="keyword">stack</span>输出的节点，一个代表向右找到的新节点。只有向右找到的新节点需要左遍历。</div></pre></td></tr></table></figure>
<p>public List<integer> inorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode node = root;<br>    while(!stack.isEmpty()) {</treenode></integer></integer></p>
<pre><code>    while(node.left!=null) {
        stack.push(node.left);
        node = node.left;
    }
    TreeNode addNode = stack.pop();
    list.add(addNode.val);

    if(addNode.right!=null) {
        stack.push(addNode.right);
        node = addNode.right;
    }    
}
return list;
</code></pre><p>}</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LeetCode - 145<span class="selector-class">.Binary</span> <span class="selector-tag">Tree</span> <span class="selector-tag">Postorder</span> <span class="selector-tag">Traversal</span>   </div><div class="line"><span class="selector-tag">Post-Order</span>递归解法:  <span class="selector-tag">Time</span> <span class="selector-tag">O</span>(n)       </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回       </div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点,<span class="selector-tag">list</span><span class="selector-class">.add</span>(root.val)</div></pre></td></tr></table></figure>
<p>public List<integer> postorderTraversalRec(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    helper(list, root);<br>    return list;<br>}</integer></integer></p>
<p>void helper(List<integer> list, TreeNode node) {<br>    if(node == null) return;<br>    helper(list, node.left);<br>    helper(list, node.right);<br>    list.add(node.val);<br>}</integer></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="type">Post</span>-<span class="type">Order</span>迭代解法:        </div><div class="line">解法一：      </div><div class="line">(<span class="number">1</span>) 使用双栈法，使用先序遍历的反向逆转</div><div class="line">(<span class="number">2</span>) 首先先序遍历是：`<span class="keyword">self</span>, <span class="keyword">left</span>, <span class="keyword">right</span>`, 反向先序遍历为`<span class="keyword">self</span>, <span class="keyword">right</span>, <span class="keyword">left</span>`, 在使用另一个stack逆转为`<span class="keyword">left</span>, <span class="keyword">right</span>, <span class="keyword">self</span>` 即为后序遍历</div><div class="line"></div><div class="line">解法二：</div><div class="line">(<span class="number">1</span>) 解法像pre-order,stack先压人root，然后压入右节点再压入左节点</div><div class="line">(<span class="number">2</span>) 有两种情况需要从stack中压出节点并添加到list中，一是左右节点为null，二是左右的节点都被访问过。</div></pre></td></tr></table></figure>
<p>//Solution1: Two stack<br>public List<integer> postorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    Stack<treenode> reverseStack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        reverseStack.push(node);<br>        if(node.left!=null) stack.push(node.left);<br>        if(node.right!=null) stack.push(node.right);<br>    }<br>    while(!reverseStack.isEmpty()) {<br>        list.add(reverseStack.pop());<br>    }<br>    return list;<br>}</treenode></treenode></integer></integer></p>
<p>//Solution2:<br>public List<integer> postorderTraversal(TreeNode root) {<br>    List<integer> list = new ArrayList&lt;&gt;();<br>    if(root == null) return list;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode prev = null;<br>    while(!stack.isEmpty()) {<br>        TreeNode node = stack.peek();<br>        //node.left==null &amp;&amp; node.right==null表明node为叶节点<br>        //prev!=null &amp;&amp; prev==node.left 表明左子树遍历完，右子树为空<br>        //prev!=null &amp;&amp; prev==node.right 表明右子树遍历完<br>        //prev!=node.left&amp;&amp;prev!=node.right表明stack已经连续输出节点到另一分支<br>        if((node.left==null &amp;&amp; node.right==null)||(prev!=null &amp;&amp; (prev == node.left || prev==node.right))) {<br>            node = stack.pop();<br>            list.add(node.val);<br>            prev = node;<br>        }else {<br>            if(node.right!=null) stack.push(node.right);<br>            if(node.left!=null) stack.push(node.left);<br>        }<br>    }<br>    return list;<br>}</treenode></integer></integer></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="attribute">4.分层遍历二叉树（按层次从上往下，从左往右）</span>: levelTraversal, levelTraversalRec（递归解法）</div><div class="line"></div><div class="line"><span class="qml">LeetCode - <span class="number">102.</span>Binary Tree Level Order Traversal </span></div><div class="line"></div><div class="line">递归解法：     </div><div class="line">记录每层个数，用层数去比较大lists的<span class="built_in">size</span>，如果<span class="built_in">size</span>等于层数，则需要添加一个新的<span class="built_in">list</span>用于记录当前层的nodes，如果<span class="built_in">size</span>小于层数，则拿出lists中相对应层数的<span class="built_in">list</span>去添加nodes.</div></pre></td></tr></table></figure>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();
    helper(lists, root,0);
    return lists;
}
void helper(List&lt;List&lt;Integer&gt;&gt; lists, TreeNode node, int level) {
    if(node == null) return;
    //add a new list to the new level of nodes
    if(lists.size() == level) lists.add(new ArrayList&lt;Integer&gt;());
    List&lt;Integer&gt; temp = lists.get(level);
    temp.add(node.val);
    helper(lists, node.left,level+1);
    helper(lists, node.right,level+1);

}
</code></pre><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法：    </div><div class="line">使用<span class="built_in">Queue</span>实现BFS</div></pre></td></tr></table></figure>
<p>//Traverse tree use BFS<br>public void levelTraversal(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>}</treenode></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="http"><span class="attribute">5.将二叉查找树变为有序的双向链表</span>: convertBST2DLLRec, convertBST2DLL</span></div><div class="line"></div><div class="line"><span class="autoit">LeetCode - <span class="number">114.</span>Flatten <span class="built_in">Binary</span> Tree <span class="keyword">to</span> Linked List </span></div><div class="line"></div><div class="line">递归解法：     </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回           </div><div class="line">(<span class="number">2</span>) 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点, 把根节点的左子树移到右边，左边致为<span class="literal">null</span>,把根节点的原右子树放到原左子树的最右边</div></pre></td></tr></table></figure>
<pre><code>public void flatten(TreeNode root) {
    if(root == null) return;

    flatten(root.left);
    flatten(root.right);

    TreeNode right = root.right;
    root.right = root.left;
    root.left = null;
    TreeNode cur = root;
    while(cur.right!=null) cur = cur.right;
    cur.right = right;

}
</code></pre><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line"><span class="number">1</span>. 依次遍历右节点</div><div class="line"><span class="number">2</span>. 每次把current <span class="keyword">node</span> <span class="title">的右子树放到左子树的最右边，然后把左子树放到右边之后，把左边致为null</span></div></pre></td></tr></table></figure>
<p>public void flatten(TreeNode root) {<br>        if(root == null) return;<br>        while(root!=null) {<br>            if(root.left==null){<br>                root = root.right;<br>                continue;<br>            }<br>            TreeNode left = root.left;<br>            while(left.right!=null) {<br>                left = left.right;<br>            }<br>            left.right = root.right;<br>            root.right = root.left;<br>            root.left = null;<br>        }</p>
<p>}<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="lsl"><span class="number">6.</span>求二叉树第K层的节点个数：getNodeNumKthLevelRec, getNodeNumKthLevel</span></div><div class="line">递归解法：即把问题分解的过程    </div><div class="line">(<span class="number">1</span>) 如果current node为null 或者 k为<span class="number">0</span>，返回<span class="number">0.</span></div><div class="line">(<span class="number">2</span>) 如果二叉树不为空且k为<span class="number">1</span>，则返回<span class="number">1.</span></div><div class="line">(<span class="number">3</span>) 如果二叉树不为空且k&gt;<span class="number">1</span>, 则返回 左子树+右子树 的个数.</div></pre></td></tr></table></figure></p>
<p>public int getNodeNumKthLevel(TreeNode root, int k) {<br>    if(root == null || k==0) return 0;<br>    if(k==1) return 1;<br>    return  getNodeNumKthLevel(root.left,k-1) + getNodeNumKthLevel(root.right,k-1);<br>}</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line"><span class="bullet">1. </span>使用BFS, 用Queue去存储每一层节点</div><div class="line"><span class="bullet">2. </span>返回某层节点数，即size of Queue</div></pre></td></tr></table></figure>
<p>//Traverse tree use BFS<br>public int getNodeNumKthLevel(TreeNode root, int k) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    int result = 0;<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        if(–k == 0){<br>            result = size;<br>            break;<br>        }<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>    return result;<br>}</treenode></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">7.</span>求二叉树中叶子节点的个数：getNodeNumLeafRec, getNodeNumLeaf </div><div class="line">递归解法：即把问题分解的过程    </div><div class="line">(<span class="number">1</span>) 如果二叉树为null，返回<span class="number">0</span></div><div class="line">(<span class="number">2</span>) 如果二叉树不为空且其左右子树均为null，则返回<span class="number">1.</span> 叶子数 = 左子树叶子数 + 右子树叶子数</div></pre></td></tr></table></figure>
<p>public int getNodeNumLeafRec(TreeNode root) {<br>    if(root == null) return 0;<br>    if(root.right==null &amp;&amp; root.left==null) return 1;<br>    return  getNodeNumLeafRec(root.left) + getNodeNumLeafRec(root.right);<br>}</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line"><span class="number">1</span>. 使用BFS, 用Queue去存储每一层节点</div><div class="line"><span class="number">2</span>. 判断每个<span class="keyword">node</span><span class="title">是否含有左子树和右子树，如果没有则 叶子数+1</span></div></pre></td></tr></table></figure>
<p>//Traverse tree use BFS<br>public int getNodeNumKthLevel(TreeNode root) {<br>    if(root == null) return 0;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    int count = 0;<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        int size = queue.size();<br>        for(int i=0;i&lt;size;i++) {<br>            TreeNode node = queue.poll();<br>            if(node.left==null &amp;&amp; node.right==null)count++;<br>            if(node.left!=null) queue.add(node.left);<br>            if(node.right!=null) queue.add(node.right);<br>        }<br>    }<br>    return count;<br>}</treenode></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="lsl"><span class="number">8.</span>判断两棵二叉树是否相同的树：isSameRec, isSame</span></div><div class="line"></div><div class="line">LeetCode - <span class="number">100.</span>Same Tree     </div><div class="line"></div><div class="line">递归解法：    </div><div class="line">(<span class="number">1</span>) 如果两个树都为空，返回true. 如果其中有一个节点为空或者两个节点的值不等，返回false. </div><div class="line">(<span class="number">2</span>) 递归遍历左子树和右子树，重复（<span class="number">1</span>）</div></pre></td></tr></table></figure>
<pre><code>public boolean isSameTree(TreeNode p, TreeNode q) {
    if(p==null &amp;&amp; q==null) return true;
    if(p==null || q==null) return false;
    if(p.val!=q.val) return false;
    if(p.val==q.val) return isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);
}
</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">   </div><div class="line"><span class="bullet">1. </span>对两个树同时使用先序遍历</div><div class="line"><span class="bullet">2. </span>每次比较两个点</div></pre></td></tr></table></figure>
<p>public boolean isSameTree(TreeNode p, TreeNode q) {        if(p==null &amp;&amp; q==null) return true;<br>        if(p==null || q==null) return false;<br>        Stack<treenode> s1 = new Stack&lt;&gt;();<br>        Stack<treenode> s2 = new Stack&lt;&gt;();<br>        s1.push(p);<br>        s2.push(q);<br>        while(!s1.isEmpty() &amp;&amp; !s2.isEmpty()) {<br>            TreeNode node1 = s1.pop();<br>            TreeNode node2 = s2.pop();<br>            if(node1==null &amp;&amp; node2==null) continue;<br>            if(node1!=null &amp;&amp; node2!=null &amp;&amp; node1.val==node2.val) {<br>                s1.push(node1.left);<br>                s1.push(node1.right);<br>                s2.push(node2.left);<br>                s2.push(node2.right);<br>            } else {<br>                return false;<br>            }<br>        }<br>        return true;<br>    }</treenode></treenode></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="armasm"><span class="number">9</span>.判断二叉树是不是平衡二叉树：<span class="keyword">isBalanced </span></span></div><div class="line"></div><div class="line"><span class="symbol">LeetCode</span> - <span class="number">110</span>.<span class="keyword">Balanced </span><span class="keyword">Binary </span>Tree</div><div class="line"></div><div class="line">递归解法<span class="number">1</span>：O(NlogN)    </div><div class="line">遍历每个点，每次都比较其左子树和右子树的高度</div></pre></td></tr></table></figure>
<pre><code>public boolean isBalanced(TreeNode root) {
    if(root==null) return true;
    if(Math.abs(getDepth(root.left)-getDepth(root.right))&gt;1) return false;
    return isBalanced(root.left) &amp;&amp; isBalanced(root.right);
}

int getDepth(TreeNode node) {
    if(node==null) return 0;
    return Math.max(getDepth(node.left),getDepth(node.right))+1;
}
</code></pre><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">递归解法<span class="number">2</span>： </div><div class="line">   </div><div class="line"><span class="number">1.</span> 自下而上，每次比较左子树和右子树，如果两边高度大于<span class="number">1</span>，则返回<span class="number">-1</span>。如果不是，则返回高度，供父节点使用。</div><div class="line"><span class="number">2.</span> 如果有一边是<span class="number">-1</span>，就直接向上，不用再求高度。</div></pre></td></tr></table></figure>
<p>public boolean isBalanced(TreeNode root) {            if(getDepth(root)==-1) return false;<br>        return true;<br>    }</p>
<pre><code>int getDepth(TreeNode node) {
    if(node==null) return 0;

    int leftDepth = getDepth(node.left);
    if(leftDepth==-1) return -1;

    int rightDepth = getDepth(node.right);
    if(rightDepth==-1) return -1;

    int diff = Math.abs(leftDepth-rightDepth);
    if(diff&gt;1) {
        return -1;
    } else {
        return Math.max(leftDepth,rightDepth) + 1;
    }
}
</code></pre><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">10.</span>求二叉树的镜像（破坏和不破坏原来的树两种情况）：</div><div class="line">     mirrorRec, mirrorCopyRec         </div><div class="line">     mirror, mirrorCopy   </div><div class="line"></div><div class="line">破坏原来的树     </div><div class="line">递归解法：   </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回null.</div><div class="line">(<span class="number">2</span>) 如果二叉树不为空, 无论有没有左右子树，交换他们的位置. 即自底向上依次调换所有左右子树位置。</div></pre></td></tr></table></figure>
<pre><code>public TreeNode mirrorRec(TreeNode root) {
    if(root==null) return null;
    TreeNode left = mirrorRec(root.left);
    TreeNode right = mirrorRec(root.right);
    root.right = left;
    root.left = right;
    return root;
}
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">使用BFS,每次遍历一个点都交换它左右子树的位置</div></pre></td></tr></table></figure>
<p>public TreeNode mirror(TreeNode root) {<br>    if(root == null) return null;<br>    Queue<treenode> queue = new LinkedList&lt;&gt;();<br>    queue.add(root);<br>    while(!queue.isEmpty()) {<br>        TreeNode node = queue.poll();<br>        if(node.left==null &amp;&amp; node.right==null) continue;<br>        TreeNode left = node.left;<br>        node.left = node.right;<br>        node.right = left;<br>        if(node.left!=null) queue.add(node.left);<br>        if(node.right!=null) queue.add(node.right);</treenode></p>
<pre><code>}
return root;
</code></pre><p>}</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">不破坏原来的树     </div><div class="line">递归解法：   </div><div class="line">(<span class="number">1</span>) 如果二叉树为空，返回null.</div><div class="line">(<span class="number">2</span>) 如果二叉树不为空, 使用先序遍历，首先创建新的节点，然后左右颠倒构造新的二叉树</div></pre></td></tr></table></figure>
<pre><code>public TreeNode mirrorCopyRec(TreeNode root) {
    if(root==null) return null;    
    TreeNode newRoot = new TreeNode(root.val);
    newRoot.left = mirrorRec(root.right);
    newRoot.right = mirrorRec(root.left);
    return newRoot;
}
</code></pre><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">使用Pre-<span class="keyword">Order</span>, 保持两个<span class="keyword">stack</span>，使新创建的点与原来的树保持一一对应.</div></pre></td></tr></table></figure>
<p>public TreeNode mirror(TreeNode root) {<br>    if(root == null) return null;<br>    Stack<treenode> stack = new Stack&lt;&gt;();<br>    Stack<treenode> newStack = new Stack&lt;&gt;();<br>    stack.push(root);<br>    TreeNode newRoot = new TreeNode(root.val);<br>    newStack.push(newRoot);<br>    while(!queue.isEmpty()) {<br>        TreeNode node = stack.pop();<br>        TreeNode newNode = newStack.pop();<br>        if(node.left!=null) {<br>            stack.push(node.left);<br>            newNode.rihgt = newTreeNode(node.left.val);<br>            stack.push(newNode.right);<br>        }<br>        if(node.right!=null) {<br>            stack.push(node.right);<br>            newNode.left = newTreeNode(node.right.val);<br>            stack.push(newNode.left);<br>        }<br>    }<br>    return newRoot;<br>}</treenode></treenode></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">10.1</span> 判断两个树是否互相镜像：isMirrorRec isMirror</div><div class="line"></div><div class="line">递归解法：   </div><div class="line">(<span class="number">1</span>) 如果两个二叉树都为空，返回<span class="literal">true</span>.</div><div class="line">(<span class="number">2</span>) 如果只有其中一个二叉树为空，返回<span class="literal">false</span>.</div><div class="line">(<span class="number">3</span>) 若果两个节点的val不相等，返回<span class="literal">false</span>.</div><div class="line">(<span class="number">4</span>) 比较一个树的左子树和另个树的右子树，以及一个树的右子树和另个树的左子树.</div></pre></td></tr></table></figure>
<pre><code>public boolean isMirrorRec(TreeNode p, TreeNode q) {
    if(p==null &amp;&amp; q==null) return true; 
    if(p==null || q==null) return false;
    if(p.val != q.val) return false;
    return isMirrorRec(p.left,q.right) &amp;&amp; isMirrorRec(p.right,q.left);
}
</code></pre><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line">使用Pre-<span class="keyword">Order</span>,每次遍历交叉树的值</div></pre></td></tr></table></figure>
<p>public boolean isMirror(TreeNode p, TreeNode q) {<br>    if(p == null &amp;&amp; q==null) return true;<br>    if(p == null || q==null) return false;<br>    Stack<treenode> stack1 = new Stack&lt;&gt;();<br>    Stack<treenode> stack2 = new Stack&lt;&gt;();<br>    stack1.push(p);<br>    stack2.push(q);<br>    while(!p.isEmpty()&amp;&amp;!q.isEmpty()) {<br>        TreeNode node1 = stack1.pop();<br>        TreeNode node2 = stack2.pop();<br>        if(node1.val != node.val) return false;<br>        if((node1.left==null&amp;&amp;node2.rihgt!=null)||(node1.left!=null&amp;&amp;node2.rihgt==null)) return false;<br>        if(node1.left!=null &amp;&amp; node2.right!=null) {<br>            stack1.push(node1.left);<br>            stack2.push(node2.right);<br>        }<br>        if((node1.rihgt==null&amp;&amp;node2.left!=null)||(node1.right!=null&amp;&amp;node2.left==null)) return false;<br>        if(node1.rihgt!=null &amp;&amp; node2.left!=null) {<br>            stack1.push(node1.right);<br>            stack2.push(node2.left);<br>        }<br>    }<br>    return true;<br>}</treenode></treenode></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="lsl"><span class="number">11.</span>求二叉树中两个节点的最低公共祖先节点：     </span></div><div class="line">       getLastCommonParent    求解最小公共祖先, 使用<span class="type">list</span>来存储path.     </div><div class="line">       getLastCommonParentRec     递归算法 .      </div><div class="line">       </div><div class="line">LeetCode - <span class="number">236.</span>Lowest Common Ancestor of a Binary Tree    </div><div class="line"></div><div class="line">递归解法：   </div><div class="line">(<span class="number">1</span>) 如果从根节点出发，分别从左右两边找到两个节点，则LastCommonParrent是根节点</div><div class="line">(<span class="number">2</span>) 如果从根节点的左子树出发，找到两节点，则LastCommonParrent在左子树</div><div class="line">(<span class="number">3</span>) 如果从根节点的右子树出发，找到两节点，则LastCommonParrent在右子树</div></pre></td></tr></table></figure>
<pre><code>//Solution1:
public TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) {
    if(findNode(root.left,p)) {
        if(findNode(root.left,q)) {
            return getLastCommonParentRec(root.left,p,q);
        }else {
            return root;
        }
    }else {
        if(findNode(root.right,q)) {
            return getLastCommonParentRec(root.right,p,q);
        }else {
            return root;
        }
    }
}

boolean findNode(TreeNode root, TreeNode node) {
    if(root==null || node==null) return false;

    if(root==node) return true;

    boolean found = findNode(root.left,node);
    if(!found) {
        found = findNode(root.right,node);
    }
    return found;
}
</code></pre><p>//Solution2:<br>public TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) {<br>    if(root==null) return null;<br>    if(root==p || root==q) return root;<br>    TreeNode commonLeft = getLastCommonParentRec(root.left,p,q);<br>    TreeNode commonRight = getLastCommonParentRec(root.right,p,q);<br>    if(commonLeft!=null &amp;&amp; commonRight!=null) return root;<br>    if(commonLeft!=null) return commonLeft;<br>    return commonRight;<br>}</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代解法： </div><div class="line"></div><div class="line"><span class="number">1.</span> 分别从根节点出发，查找到达两个节点的路径，用<span class="type">list</span>保存</div><div class="line"><span class="number">2.</span> 然后同时比较两个<span class="type">list</span>中的点，找出最后相同的两个点（两个<span class="type">list</span>前面的点都相同）</div></pre></td></tr></table></figure>
<p>public TreeNode getLastCommonParentRec(TreeNode root, TreeNode p, TreeNode q) {<br>    ArrayList<treenode> list1 = new ArrayList&lt;&gt;();<br>    ArrayList<treenode> list2 = new ArrayList&lt;&gt;();<br>    boolean found1 = findPath(root,p,list1);<br>    boolean found2 = findPath(root,q,list2);<br>    if(!found1 || !found2) return null;</treenode></treenode></p>
<pre><code>TreeNode result = null;
for(int i=0;i&lt;Math.min(list1.size(),list2.size());i++) {
    if(list1.get(i)==list2.get(i)){
        result = list1.get(i);
    }else break;
}
return result;
</code></pre><p>}</p>
<p>boolean findPath(TreeNode root, TreeNode node, ArrayList<treenode> list) {<br>    if(root==null || node==null) return false;<br>    list.add(root);<br>    if(root == node) return true;<br>    boolean found = findPath(root.left,node,list);<br>    if(!found) {<br>        found = findPath(root.right,node,list);<br>    }<br>    if(!found) list.remove(root);<br>    return found;<br>}</treenode></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">       </div><div class="line"><span class="number">12.</span>求二叉树中节点的最大距离：getMaxDistanceRec     </div><div class="line"></div><div class="line">递归法：      </div><div class="line">(<span class="number">1</span>)求最大距离有两种情况：一是两个最大深度相加，它分别位于根节点的两侧；一是某个子节点下两个分支距离的和最大       </div><div class="line">(<span class="number">2</span>)创建一个类去记录最大距离和最大深度，每次记录每个点的深度，以及最长距离</div></pre></td></tr></table></figure>
<p>public int getMaxDistanceRec(TreeNode root) {<br>    Distance dis = getDistance(root);<br>    return dis.maxDistance;<br>}</p>
<p>private Distance getDistance(TreeNode node) {<br>    //最底一层，深度为0<br>    if(node==null){<br>        Distance empty = new Distance(0,-1);<br>        return empty;<br>    }</p>
<pre><code>Distance left = getDistance(node.left);
Distance right = getDistance(node.right);

Distance dis = new Distance();
dis.maxDepth = Math.max(left.maxDepth,right.maxDepth)+1;
dis.maxDistance = Math.max(left.maxDepth+right.maxDepth+2,Math.max(left.maxDistance,right.maxDistance));
return dis;
</code></pre><p>}</p>
<p>class Distance {<br>    int maxDistance;<br>    int maxDepth;<br>    public Distance(){}<br>    public Distance(int maxDistance,int maxDepth){<br>        this.maxDistance = maxDistance;<br>        this.maxDepth = maxDepth;<br>    }<br> }</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">13.</span>由前序遍历序列和中序遍历序列重建二叉树：rebuildBinaryTreeRec</div><div class="line"></div><div class="line">LeetCode - <span class="number">105.</span> Construct Binary Tree from Preorder and Inorder Traversal     </div><div class="line"></div><div class="line"></div><div class="line">递归解法：</div><div class="line"></div><div class="line"><span class="number">1.</span> 由前序遍历可以知道第一个点是root，接下来几个点是左子树的点，之后几个是右子树的点, 特点是大体排列次序按照每个树的根节点顺序排列。</div><div class="line"><span class="number">2.</span> 由中序遍历可以知道root点左边的都是左子树的点，右边都是右子树的点.可以得出左子树和右子树节点数</div></pre></td></tr></table></figure>
<p>public TreeNode rebuildBinaryTreeRec(int[]preorder,int[]inorder) {<br>    return buildTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1);<br>}</p>
<p>TreeNode buildTree(int[]preorder,int preStart, int preEnd, int[]inorder, int inStart, int inEnd) {<br>    if(preStart &gt; preEnd) return null;<br>    int rootVal = preorder[preStart];<br>    int inRoot=-1;<br>    for(int i=inStart,j=inEnd; i&lt;=j; i++,j–) {<br>        if(inorder[i] == rootVal) {<br>            inRoot = i;<br>            break;<br>        }else if(inorder[j] == rootVal){<br>            inRoot = j;<br>            break;<br>        }<br>    }<br>    TreeNode root = new TreeNode(rootVal);<br>    root.left = buildTree(preorder,preStart+1,preStart+(inRoot-inStart), inorder,inStart,inRoot-1);<br>    root.right = buildTree(preorder,preEnd-(inEnd-inRoot)+1,preEnd,inorder,inRoot+1,inEnd);<br>    return root;<br>}</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="lsl"></span></div><div class="line"><span class="number">14.</span>判断二叉树是不是完全二叉树：isCompleteBinaryTree, isCompleteBinaryTreeRec</div><div class="line"></div><div class="line">迭代解法： </div><div class="line">(<span class="number">1</span>)使用BFS遍历节点，每层节点中，如果遇到左右子树为空时，或者遇到的第一个左子树不为空但右子树为空的情况，则后面所有的左右子树必须为空。即为完全二叉树。     </div><div class="line">(<span class="number">2</span>)设立一个标志，如果有个节点的左右子树为空，则之后所有节点的子树必须为空。</div></pre></td></tr></table></figure>
<p>public boolean isCompleteBinaryTree(TreeNode root) {<br>    if(root == null) return false;<br>    Queue<treenode> queue = new Queue&lt;&gt;();<br>    queue.add(root);<br>    boolean flag = true;<br>    while(!queue.isEmpty()) {<br>        TreeNode node = queue.poll();<br>        if(flag) {<br>            if(node.left==null &amp;&amp; node.right==null) flag = false;<br>            else if(node.left==null &amp;&amp; node.right!=null) return false;<br>            else if(node.left!=null &amp;&amp; node.right==null) {<br>                flag = false;<br>                queue.add(node.left);<br>            }else {<br>                queue.add(node.left);<br>                queue.add(node.right);<br>            }</treenode></p>
<pre><code>    }else {
        if(node.left!=null || node.right!=null) return false;
    }
}
return true;
</code></pre><p>}</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="livecodeserver"><span class="number">15.</span>找出二叉树中最长连续子串(即全部往左的连续节点，或是全部往右的连续节点）findLongest</span></div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line"><span class="comment">## 学习后总结：</span></div><div class="line"><span class="comment">### When to use Pre-Order, In-Order, Post-Order</span></div><div class="line"></div><div class="line">- Pre-Order: Recursively, this is `self, left, <span class="literal">right</span>`. From root node <span class="built_in">to</span> <span class="literal">right</span> most node. Firstly, <span class="keyword">if</span> you know you need <span class="built_in">to</span> explore <span class="keyword">the</span> roots <span class="keyword">before</span> inspecting <span class="keyword">any</span> leaves, you should pick pre-order because you will encounter all <span class="keyword">the</span> roots <span class="keyword">before</span> all <span class="keyword">of</span> <span class="keyword">the</span> leaves.  Secondly, <span class="keyword">if</span> you want <span class="built_in">to</span> simply print out <span class="keyword">the</span> hierachical <span class="built_in">format</span> <span class="keyword">of</span> <span class="keyword">the</span> tree <span class="keyword">in</span> <span class="keyword">a</span> linear <span class="built_in">format</span>, use preorder traversal.</div></pre></td></tr></table></figure>
<ul>
<li>Root<ul>
<li>A<ul>
<li>B</li>
<li>C</li>
</ul>
</li>
<li>D<ul>
<li>E</li>
<li>F<br>  -G    </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- Post-Order: Recursively, this is`left, right, self`. From left most <span class="keyword">node</span> <span class="title">to</span> right most <span class="keyword">node</span>.  <span class="title">If</span> you know you need to explore all the leaves before any nodes, you should pick post-<span class="keyword">order</span> <span class="title">because</span> you don't waster any time inspecting roots <span class="keyword">in</span> search for leaves. 或者应用在：树的删除。为了释放树结构的内存，某节点在被释放以前，其左右子树的节点首先应当被释放掉。</div><div class="line">- <span class="keyword">In</span>-Order: Recursively, this is`left, self, right`. From left most <span class="keyword">node</span> <span class="title">to</span> right most <span class="keyword">node</span>. <span class="title">If</span> you know that the tree has an inherent sequence, <span class="keyword">and</span> you want to flatten the tree back into the original sequence(simply process the items <span class="keyword">in</span> the <span class="keyword">defined</span> order).</div></pre></td></tr></table></figure>
<p>For example, you have a BST of a list of number, inorder traversal would print them out in ascending order.</p>
<pre><code>+
</code></pre><p>  /      \<br> A     *<br>      /  \<br>     B    C</p>
<p>Output: A + B * C</p>
<p>If you want to evaluate the expression, you traverse the tree in postorder, applying each operator to the values from each of its sub-trees.      </p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="oxygene">### When <span class="keyword">to</span> use BFS <span class="keyword">and</span> DFS, the relationship between DFS <span class="keyword">and</span> PreOrder</span></div><div class="line"></div><div class="line">DFS 包括: </div><div class="line">  </div><div class="line"><span class="number">1</span>. Pre-<span class="keyword">Order</span>, <span class="keyword">In</span>-<span class="keyword">Order</span>, Post-<span class="keyword">Order</span></div><div class="line"><span class="number">2</span>. Divide &amp; Conquer</div><div class="line"></div><div class="line">Notice：     </div><div class="line">Sometimes it <span class="keyword">is</span> easy <span class="keyword">to</span> figure <span class="keyword">out</span> question <span class="keyword">using</span> Recursion.  So interviewer wants you <span class="keyword">to</span> use Iterative solution.  因为这里，递归的方法和变量都是存储在Stack中的，现在就是想考验你去实现栈的内部工作原理，使用iteration 都需要去借助一个数据结构来完成recursion的方法。</div><div class="line"></div><div class="line">DFS Template:</div><div class="line"></div><div class="line"><span class="number">1</span>.Recursively Traverse</div></pre></td></tr></table></figure>
<p>public void traversal(TreeNode root) {<br>    if(roo==null) return;</p>
<pre><code>traversal(root.left);

traversal(root.right);
</code></pre><p>}</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span><span class="selector-class">.Divide</span> &amp; Conquer</div></pre></td></tr></table></figure>
<p>public ResultType traversal(TreeNode root) {<br>    if(root==null) {<br>        return null;<br>    }</p>
<pre><code>//Divide
ResultType left = traversal(root.left);
ResultType right = traversal(root.right);

//Conquer
ResultType result = Merge from left to right
return result;
</code></pre><p>}</p>
<p>```</p>
<h3 id="How-to-think-over-Divide-amp-Conquer"><a href="#How-to-think-over-Divide-amp-Conquer" class="headerlink" title="How to think over Divide&amp;Conquer"></a>How to think over Divide&amp;Conquer</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是关于二叉树Binary Tree算法的分析和总结。&lt;/p&gt;
&lt;h2 id=&quot;攻略模板&quot;&gt;&lt;a href=&quot;#攻略模板&quot; class=&quot;headerlink&quot; title=&quot;攻略模板&quot;&gt;&lt;/a&gt;攻略模板&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;回忆算法特性&lt;/li&gt;
&lt;li&gt;实现算法
    
    </summary>
    
      <category term="Algorithm" scheme="http://xinli90.com/categories/Algorithm/"/>
    
    
      <category term="Seeking Job" scheme="http://xinli90.com/tags/Seeking-Job/"/>
    
  </entry>
  
  <entry>
    <title>Two Sum III - Data structure design</title>
    <link href="http://xinli90.com/2016/08/19/Two-Sum-III-Data-structure-design/"/>
    <id>http://xinli90.com/2016/08/19/Two-Sum-III-Data-structure-design/</id>
    <published>2016-08-19T20:56:56.000Z</published>
    <updated>2016-08-28T20:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/two-sum-iii-data-structure-design/" target="_blank" rel="external">Leetcode-Two Sum III - Data structure design</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Design and implement a TwoSum class. It should support the following operations: add and find.</p>
<p>add - Add the number to an internal data structure.<br>find - Find if there exists any pair of numbers which sum is equal to the value.</p>
<p>For example,</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">add(<span class="number">1</span>); add(<span class="number">3</span>); add(<span class="number">5</span>);</div><div class="line">find<span class="function"><span class="params">(<span class="number">4</span>)</span> -&gt;</span> <span class="literal">true</span></div><div class="line">find<span class="function"><span class="params">(<span class="number">7</span>)</span> -&gt;</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><ol>
<li>Time complexity is O(n), space complexity is O(n)</li>
<li>Store number and its frequency into HashMap</li>
<li>If target-number==number and frequency is less than 2, then we should continue to search through map.containsKey(target-key).</li>
<li>But time limit exceeded.</li>
</ol>
<h4 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h4><ol>
<li>Time complexity is O(n^2), space complexity is O(n)</li>
<li>Brute solution but time limit exceeded.</li>
</ol>
<h4 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h4><ol>
<li>Time complexity is O(nlogn), space complexity is O(n)</li>
<li>Sort the list and then keep two pointers move from head and tail respectively to combine and compare.</li>
<li>But time limit exceeded.</li>
</ol>
<h4 id="Solution4"><a href="#Solution4" class="headerlink" title="Solution4"></a>Solution4</h4><ol>
<li>Time complexity is O(n), space complexity is O(n)</li>
<li>Using ArrayList add and remove, Still time limit exceeded.</li>
</ol>
<h4 id="Solution5"><a href="#Solution5" class="headerlink" title="Solution5"></a>Solution5</h4><ol>
<li>Time complexity is O(n), space complexity is O(n)</li>
<li>Using ArrayList and HashMap instead of iterating hashmap. Beats 99%. Done!</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Solution1</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> TwoSum &#123;</div><div class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Integer&gt; <span class="built_in">map</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoSum</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Add the number to an internal data structure.</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">	    <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(number))&#123;</div><div class="line">	        <span class="keyword">int</span> count = <span class="built_in">map</span>.get(number);</div><div class="line">	        <span class="built_in">map</span>.put(number,count+<span class="number">1</span>);</div><div class="line">	    &#125;<span class="keyword">else</span>&#123;</div><div class="line">	        <span class="built_in">map</span>.put(number,<span class="number">1</span>);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">// Find if there exists any pair of numbers which sum is equal to the value.</span></div><div class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">	    Iterator&lt;Integer&gt; it = <span class="built_in">map</span>.keySet().iterator();</div><div class="line">	    <span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">	        <span class="keyword">int</span> num = it.next();</div><div class="line">	        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(value-num)) &#123;</div><div class="line">	            <span class="keyword">if</span>((value == num*<span class="number">2</span>) &amp;&amp; (<span class="built_in">map</span>.get(num) == <span class="number">1</span>)) <span class="keyword">continue</span>;</div><div class="line">	            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Solution2</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> TwoSum &#123;</div><div class="line">    List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="comment">// Add the number to an internal data structure.</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">	    <span class="built_in">list</span>.add(number);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">// Find if there exists any pair of numbers which sum is equal to the value.</span></div><div class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">list</span>.size()<span class="number">-1</span>; i++) &#123;</div><div class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;<span class="built_in">list</span>.size(); j++) &#123;</div><div class="line">	            <span class="keyword">if</span>(value==<span class="built_in">list</span>.get(i)+<span class="built_in">list</span>.get(j))<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Solution3</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> TwoSum &#123;</div><div class="line">    List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="comment">// Add the number to an internal data structure.</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">	    <span class="built_in">list</span>.add(number);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">// Find if there exists any pair of numbers which sum is equal to the value.</span></div><div class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">	    Collections.sort(<span class="built_in">list</span>);</div><div class="line">	    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">list</span>.size()<span class="number">-1</span>;</div><div class="line">	    <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">	        <span class="keyword">if</span>(value == <span class="built_in">list</span>.get(left)+<span class="built_in">list</span>.get(right)) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	        <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; <span class="built_in">list</span>.get(left)+<span class="built_in">list</span>.get(right)) left++;</div><div class="line">	        <span class="keyword">else</span> right--;</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Solution4</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> TwoSum &#123;</div><div class="line">    ArrayList&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="comment">//HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();</span></div><div class="line">    <span class="comment">// Add the number to an internal data structure.</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">	    <span class="built_in">list</span>.add(number);</div><div class="line">	   </div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">// Find if there exists any pair of numbers which sum is equal to the value.</span></div><div class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">list</span>.size() ; i++) &#123;</div><div class="line">	        <span class="keyword">int</span> num = <span class="built_in">list</span>.get(i);</div><div class="line">	        <span class="built_in">list</span>.remove(i);</div><div class="line">	        <span class="keyword">if</span>(<span class="built_in">list</span>.contains(Integer.valueOf(value-num))) &#123;</div><div class="line">	            <span class="built_in">list</span>.add(i,num);</div><div class="line">	            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	        &#125;</div><div class="line">	        <span class="built_in">list</span>.add(i,num);</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Solution5:</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> TwoSum &#123;</div><div class="line">    ArrayList&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    HashMap&lt;Integer,Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</div><div class="line">    <span class="comment">// Add the number to an internal data structure.</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">	    <span class="built_in">list</span>.add(number);</div><div class="line">	    <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(number))&#123;</div><div class="line">	        <span class="keyword">int</span> count = <span class="built_in">map</span>.get(number);</div><div class="line">	        <span class="built_in">map</span>.put(number,count+<span class="number">1</span>);</div><div class="line">	    &#125;<span class="keyword">else</span>&#123;</div><div class="line">	        <span class="built_in">map</span>.put(number,<span class="number">1</span>);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">// Find if there exists any pair of numbers which sum is equal to the value.</span></div><div class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">list</span>.size() ; i++) &#123;</div><div class="line">	        <span class="keyword">int</span> num = <span class="built_in">list</span>.get(i);</div><div class="line">	        <span class="keyword">int</span> another = value-num;</div><div class="line">	        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(another)) &#123;</div><div class="line">	            <span class="keyword">if</span>((another == num) &amp;&amp; (<span class="built_in">map</span>.get(num) == <span class="number">1</span>)) <span class="keyword">continue</span>;</div><div class="line">	            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Your TwoSum object will be instantiated and called as such:</span></div><div class="line"><span class="comment">// TwoSum twoSum = new TwoSum();</span></div><div class="line"><span class="comment">// twoSum.add(number);</span></div><div class="line"><span class="comment">// twoSum.find(value);</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/two-sum-iii-data-structure-design/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leet
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Two Sum II - Input array is sorted</title>
    <link href="http://xinli90.com/2016/08/18/Two-Sum-II-Input-array-is-sorted/"/>
    <id>http://xinli90.com/2016/08/18/Two-Sum-II-Input-array-is-sorted/</id>
    <published>2016-08-18T20:03:43.000Z</published>
    <updated>2016-08-28T20:27:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="external">Leetcode-Two Sum II - Input array is sorted</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.        </p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.        </p>
<p>You may assume that each input would have exactly one solution.      </p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: <span class="attr">numbers=&#123;2,</span> <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;, <span class="attr">target=9</span>      </div><div class="line">Output: <span class="attr">index1=1,</span> <span class="attr">index2=2</span></div></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1-and-2"><a href="#Solution1-and-2" class="headerlink" title="Solution1 and 2"></a>Solution1 and 2</h4><p>Based on <code>Two Sum</code> solution, and add pruning solution.</p>
<h4 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h4><ol>
<li>Keep two pointers. One moves from head and another moves from tail.</li>
<li>If the sum of two values is greater than target, move second pointer to the left.</li>
<li>If the sum of two values is less than target, move first pointer to the right.</li>
<li>Until we find the right one.</li>
<li>Time complexity is O(n), space complexity is O(1).</li>
</ol>
<h4 id="Solution4"><a href="#Solution4" class="headerlink" title="Solution4"></a>Solution4</h4><ol>
<li>For each left pointer,  Use Binary Seach to find the right pointer.</li>
<li>Time complexity is O(nlogn), space complexity is O(1).</li>
</ol>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution1 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</div><div class="line">		<span class="built_in">int</span> size = nums.length;</div><div class="line">		<span class="built_in">int</span>[] result = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;size<span class="number">-1</span>; i++) &#123;</div><div class="line">			<span class="keyword">if</span>(numbers[i] &gt; target) break;</div><div class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> j=i+<span class="number">1</span>; j&lt;size; j++) &#123;</div><div class="line">				<span class="keyword">if</span>(numbers[i]+numbers[j] &gt; target)break;</div><div class="line">				<span class="keyword">if</span>(target == nums[i] + nums[j])&#123;</div><div class="line">					result[<span class="number">0</span>] = i;</div><div class="line">					result[<span class="number">1</span>] = j;</div><div class="line">					return result;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">			</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution3 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</div><div class="line">		<span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.length<span class="number">-1</span>;</div><div class="line">		<span class="keyword">while</span>(<span class="built_in">left</span>&lt;<span class="built_in">right</span>) &#123;</div><div class="line">			<span class="keyword">if</span>(nums[<span class="built_in">left</span>]+nums[<span class="built_in">right</span>] == target) return <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="built_in">left</span>+<span class="number">1</span>, <span class="built_in">right</span>+<span class="number">1</span>&#125;;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">left</span>]+nums[<span class="built_in">right</span>] &lt; target)&#123;</div><div class="line">				<span class="built_in">left</span>++;</div><div class="line">			&#125;<span class="keyword">else</span> <span class="built_in">right</span>--;</div><div class="line">		&#125;</div><div class="line">		return <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution4 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</div><div class="line">		<span class="built_in">int</span> size = nums.length;</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;size<span class="number">-1</span>; i++) &#123;</div><div class="line">			<span class="built_in">int</span> <span class="built_in">left</span> = i+<span class="number">1</span>, <span class="built_in">right</span> = size - <span class="number">1</span>;</div><div class="line">			<span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>) &#123;</div><div class="line">				<span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span>-<span class="built_in">left</span>)/<span class="number">2</span>;</div><div class="line">				<span class="keyword">if</span>(nums[<span class="built_in">mid</span>] == target-nums[i]) return <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;i+<span class="number">1</span>,<span class="built_in">mid</span>+<span class="number">1</span>&#125;;</div><div class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &lt; target-nums[i]) <span class="built_in">left</span> = <span class="built_in">mid</span>+<span class="number">1</span>;</div><div class="line">				<span class="keyword">else</span> <span class="built_in">right</span> = <span class="built_in">mid</span><span class="number">-1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetc
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Two Sum</title>
    <link href="http://xinli90.com/2016/08/17/Two-Sum/"/>
    <id>http://xinli90.com/2016/08/17/Two-Sum/</id>
    <published>2016-08-17T20:35:54.000Z</published>
    <updated>2016-08-28T20:24:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is the solution about <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="external">Leetcode-Two Sum</a>.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Example:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</div><div class="line"></div><div class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</div><div class="line">return [<span class="number">0</span>, <span class="number">1</span>].</div></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><ol>
<li>Time complexity is O(n^2), space complexity is O(1)</li>
<li>Loop this array and find the right pair.</li>
<li>Note: we cannot change the original order.</li>
</ol>
<h4 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h4><p>Time complexity is O(n), space complexity is O(n)</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution1 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">		<span class="keyword">int</span> <span class="built_in">size</span> = nums.length;</div><div class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">		<span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">size</span><span class="number">-1</span>; i++) &#123;</div><div class="line">			<span class="built_in">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;<span class="built_in">size</span>; j++) &#123;</div><div class="line">				<span class="built_in">if</span>(target == nums[i] + nums[j])&#123;</div><div class="line">					result[<span class="number">0</span>] = i;</div><div class="line">					result[<span class="number">1</span>] = j;</div><div class="line">					<span class="built_in">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> result;</div><div class="line">	&#125;</div><div class="line">			</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution2 &#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">		HashMap&lt;Integer,Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">		<span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</div><div class="line">			<span class="built_in">if</span>(<span class="built_in">map</span>.containsKey(target-nums[i])) &#123;</div><div class="line">				<span class="built_in">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="built_in">map</span>.<span class="built_in">get</span>(target-nums[i]),i&#125;;</div><div class="line">			&#125;<span class="built_in">else</span> &#123;</div><div class="line">				<span class="built_in">map</span>.<span class="built_in">put</span>(nums[i],i);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the solution about &lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Leetcode-Two Sum&lt;/a&gt;.&lt;/p&gt;
&lt;h2 
    
    </summary>
    
      <category term="Leetcode" scheme="http://xinli90.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://xinli90.com/tags/Leetcode/"/>
    
  </entry>
  
</feed>
